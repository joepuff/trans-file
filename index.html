<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å±€åŸŸç½‘äº’ä¼  V27 [100æ®µåˆ†æ²»]</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    <style>
        :root { --primary: #007aff; --success: #34c759; --error: #ff3b30; --bg: #f5f5f7; --card: #fff; }
        body { font-family: -apple-system, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background: var(--bg); color: #1c1c1e; }
        .card { background: var(--card); padding: 24px; border-radius: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); margin-bottom: 20px; }
        
        .input-group { display: flex; gap: 8px; margin-bottom: 20px; }
        input[type="text"] { flex: 1; padding: 12px; border: 1px solid #e5e5ea; border-radius: 10px; font-family: monospace; letter-spacing: 2px; text-align: center; }
        button { border: none; padding: 0 16px; border-radius: 10px; font-weight: 600; cursor: pointer; background: #e5e5ea; font-size: 0.9rem; }
        .btn-main { background: var(--primary); color: white; }

        /* 100å®«æ ¼å¸ƒå±€ (10x10) */
        .grid-100 { display: grid; grid-template-columns: repeat(10, 1fr); gap: 3px; margin: 20px 0; }
        .grid-item { aspect-ratio: 1; background: #e5e5ea; border-radius: 3px; font-size: 0; transition: 0.2s; }
        
        .grid-item.done { background: var(--success); }
        .grid-item.sending { background: var(--primary); opacity: 0.8; }
        .grid-item.error { background: var(--error); }

        .drop-zone { border: 2px dashed #c7c7cc; padding: 30px; text-align: center; border-radius: 12px; cursor: pointer; margin-top: 20px; }
        .log-item { padding: 10px 0; border-bottom: 1px solid #eee; font-size: 0.85rem; display: flex; justify-content: space-between; align-items: center; }
        
        .modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); align-items: center; justify-content: center; z-index: 99; }
        #qrcode-gen { background: white; padding: 20px; border-radius: 16px; }
    </style>
</head>
<body>
    <div class="card">
        <h3>V27 ä¸–çºªç‰ˆ <span style="font-size:0.8rem;background:#000;color:#fff;padding:2px 6px;border-radius:4px;">100 Segments</span></h3>
        <div style="color:#8e8e93; font-size:0.8rem; margin-bottom:15px">100æ®µç²¾ç»†åˆ‡åˆ† â€¢ å¯†é’¥å¾ªç¯å¤ç”¨ â€¢ æè‡´é¢—ç²’åº¦</div>

        <div class="input-group">
            <input type="text" id="credentialInput" placeholder="è¾“å…¥32ä½å¯†é’¥" maxlength="32">
        </div>
        <div class="input-group">
            <button onclick="App.genKey()">ğŸ²</button>
            <button onclick="App.showQR()">ğŸ“±</button>
            <button onclick="App.scanQR()">ğŸ“·</button>
            <button class="btn-main" style="flex:2" onclick="App.init()">ğŸš€ è¿æ¥</button>
        </div>
        <div id="status" style="text-align:center; color:#666; font-size:0.9rem;">ç­‰å¾…è¿æ¥...</div>

        <div id="panel" style="display:none">
            <div class="grid-100" id="statusGrid"></div>
            <div id="progress-text" style="text-align:center; font-size:0.8rem; color:#8e8e93; margin-bottom:10px;">å°±ç»ª</div>

            <div class="drop-zone" onclick="document.getElementById('fileInput').click()">
                <div style="font-size:2rem">ğŸ“¦</div>
                <div>ç‚¹å‡»é€‰æ‹©æ–‡ä»¶ (è‡ªåŠ¨åˆ‡åˆ†100æ®µ)</div>
                <input type="file" id="fileInput" style="display:none">
            </div>
        </div>
    </div>

    <div class="card">
        <h4>ä¼ è¾“è®°å½•</h4>
        <div id="history"></div>
    </div>

    <div id="qr-modal" class="modal" onclick="this.style.display='none'"><div id="qrcode-gen"></div></div>
    <div id="scan-modal" class="modal"><div style="background:white;padding:10px;border-radius:10px"><div id="reader" style="width:300px"></div><button onclick="App.stopScan()" style="width:100%;margin-top:10px;padding:10px">å…³é—­</button></div></div>

    <script>
        const CONFIG = {
            CHUNK_SIZE: 16 * 1024, 
            TOTAL_PARTS: 100, // ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼š100æ®µ
            SALT: "V27_CENTURY_SALT"
        };

        const MultiCrypto = {
            subKeys: [],
            async init(mainKey) {
                if(mainKey.length !== 32) throw new Error("Key len != 32");
                this.subKeys = [];
                const enc = new TextEncoder();
                // ä¾ç„¶åªç”Ÿæˆ16ç»„åŸºç¡€å¯†é’¥
                for(let i=0; i<16; i++) {
                    const subSeed = mainKey.substr(i*2, 2);
                    const keyMat = await crypto.subtle.importKey("raw", enc.encode(subSeed + CONFIG.SALT), {name:"PBKDF2"}, false, ["deriveKey"]);
                    const key = await crypto.subtle.deriveKey({ name: "PBKDF2", salt: enc.encode(i.toString()), iterations: 5000, hash: "SHA-256" }, keyMat, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
                    this.subKeys.push(key);
                }
                const hash = await crypto.subtle.digest('SHA-256', enc.encode(mainKey));
                return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join('').slice(0, 32);
            },
            // ğŸ”¥ å¯†é’¥å¾ªç¯é€»è¾‘ï¼šå–ä½™æ•° (partIndex % 16)
            async encrypt(partIndex, chunkData) {
                const keyIndex = partIndex % 16; 
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const cipher = await crypto.subtle.encrypt({name:"AES-GCM", iv}, this.subKeys[keyIndex], chunkData);
                const packed = new Uint8Array(12 + cipher.byteLength);
                packed.set(iv, 0); packed.set(new Uint8Array(cipher), 12);
                return packed;
            },
            async decrypt(partIndex, packedData) {
                const keyIndex = partIndex % 16;
                const iv = packedData.slice(0, 12);
                const cipher = packedData.slice(12);
                return await crypto.subtle.decrypt({name:"AES-GCM", iv}, this.subKeys[keyIndex], cipher);
            }
        };

        const App = {
            peer: null, conn: null,
            state: { 
                file: null, parts: [], meta: null, 
                partCounts: new Array(CONFIG.TOTAL_PARTS).fill(0), 
                hasError: false 
            },

            async init() {
                const input = document.getElementById('credentialInput').value.trim();
                if(input.length !== 32) return UI.setStatus("âŒ å¿…é¡»è¾“å…¥32ä½å¯†é’¥");
                UI.setStatus("ğŸ” ç”Ÿæˆå¯†é’¥...");
                try {
                    const roomId = await MultiCrypto.init(input);
                    this.startPeer(roomId);
                } catch(e) { UI.setStatus("âŒ å¯†é’¥é”™è¯¯"); }
            },

            startPeer(id) {
                if(this.peer) this.peer.destroy();
                this.peer = new Peer(id, {
                    host: '0.peerjs.com', port: 443, secure: true,
                    config: { iceServers: [{ urls: 'stun:stun.miwifi.com' }] }
                });
                this.peer.on('open', () => { UI.setStatus("âœ… å°±ç»ª (Host)"); this.peer.on('connection', c => this.setupConn(c)); });
                this.peer.on('error', e => { if(e.type==='unavailable-id'){ UI.setStatus("ğŸ”— è¿æ¥ Host..."); const g=new Peer(); g.on('open',()=>this.setupConn(g.connect(id))); } });
            },

            setupConn(c) {
                this.conn = c;
                c.on('open', () => { UI.setStatus("ğŸ¤ å·²è¿æ¥"); document.getElementById('panel').style.display='block'; UI.renderGrid(); });
                c.on('data', d => this.handleData(d));
                c.on('close', () => UI.setStatus("ğŸ”Œ æ–­å¼€"));
            },

            async sendFile(file) {
                this.state.file = file;
                UI.resetGrid();
                // ğŸ”¥ è®¡ç®—100ä»½çš„å¤§å°
                const partSize = Math.ceil(file.size / CONFIG.TOTAL_PARTS);
                this.conn.send({ type: 'meta', name: file.name, size: file.size, mime: file.type });
                
                UI.setProgress(`å‡†å¤‡å‘é€: ${file.name}`);

                for(let i=0; i < CONFIG.TOTAL_PARTS; i++) {
                    UI.setGrid(i, 'sending');
                    const start = i * partSize;
                    const end = Math.min(start + partSize, file.size);
                    
                    if(start >= file.size) {
                        this.conn.send({ type: 'part-end', p: i, count: 0 }); // ç©ºæ®µ
                        UI.setGrid(i, 'done');
                        continue;
                    }

                    const partBlob = file.slice(start, end);
                    await this.sendPart(i, partBlob);
                    UI.setGrid(i, 'done');
                }
                this.conn.send({ type: 'all-done' });
                UI.setProgress("âœ… å‘é€å®Œæˆ");
            },

            async sendPart(p, blob) {
                const buffer = await blob.arrayBuffer();
                const totalChunks = Math.ceil(buffer.byteLength / CONFIG.CHUNK_SIZE);
                
                for(let j=0; j<totalChunks; j++) {
                    // èƒŒå‹æµæ§ï¼šæ ¸å¿ƒé˜²ä¸¢åŒ…
                    while (this.conn.dataChannel.bufferedAmount > 64 * 1024) await new Promise(r => setTimeout(r, 5));

                    const chunkOffset = j * CONFIG.CHUNK_SIZE;
                    const chunkData = buffer.slice(chunkOffset, chunkOffset + CONFIG.CHUNK_SIZE);
                    const encrypted = await MultiCrypto.encrypt(p, chunkData);
                    
                    this.conn.send({ type: 'data', p: p, c: j, d: encrypted });
                }
                this.conn.send({ type: 'part-end', p: p, count: totalChunks });
            },

            async handleData(data) {
                if(data.type === 'meta') {
                    this.state.meta = data;
                    this.state.parts = new Array(CONFIG.TOTAL_PARTS).fill(null).map(() => []);
                    this.state.partCounts = new Array(CONFIG.TOTAL_PARTS).fill(0);
                    this.state.hasError = false;
                    UI.resetGrid();
                    UI.setProgress(`â¬‡ å¼€å§‹æ¥æ”¶ (100 Segs)`);
                    return;
                }

                if(data.type === 'data') {
                    const { p, c, d } = data;
                    if(this.state.hasError) return;
                    UI.setGrid(p, 'sending');
                    try {
                        const decrypted = await MultiCrypto.decrypt(p, d);
                        this.state.parts[p][c] = decrypted;
                        this.state.partCounts[p]++;
                    } catch(e) { console.error(e); }
                    return;
                }

                if(data.type === 'part-end') {
                    const { p, count } = data;
                    const received = this.state.partCounts[p];
                    
                    // å®Œæ•´æ€§æ ¡éªŒ
                    if (received !== count) {
                        UI.setGrid(p, 'error');
                        UI.setProgress(`âŒ é”™è¯¯ï¼šç¬¬${p+1}æ®µä¸¢åŒ… (${received}/${count})`);
                        this.state.hasError = true;
                        return;
                    }

                    if(this.state.parts[p].length > 0) {
                        // æ ¡éªŒç©ºæ´
                        for(let k=0; k<count; k++) if(!this.state.parts[p][k]) {
                            UI.setGrid(p, 'error'); this.state.hasError = true; return;
                        }
                        this.state.parts[p] = new Blob(this.state.parts[p]); 
                    }
                    UI.setGrid(p, 'done');
                }

                if(data.type === 'all-done') {
                    if(!this.state.hasError) this.assembleFile();
                    else UI.setProgress("âŒ ä¼ è¾“å¤±è´¥");
                }
            },

            assembleFile() {
                try {
                    const meta = this.state.meta;
                    const validParts = this.state.parts.map(p => {
                        if(p instanceof Blob) return p;
                        if(Array.isArray(p) && p.length===0) return new Blob([]);
                        throw new Error("Missing");
                    });

                    const finalBlob = new Blob(validParts, { type: meta.mime });
                    const url = URL.createObjectURL(finalBlob);
                    
                    UI.addHistory(meta.name, meta.size, url);
                    UI.setProgress("âœ… 100æ®µæ ¡éªŒå®Œæ•´ï¼Œåˆå¹¶æˆåŠŸ");
                    this.state.parts = []; 
                } catch(e) { UI.setProgress("âŒ åˆå¹¶å¤±è´¥"); }
            },

            genKey: () => document.getElementById('credentialInput').value = Array.from(crypto.getRandomValues(new Uint8Array(16))).map(b=>b.toString(16).padStart(2,'0')).join(''),
            showQR: () => { const v=document.getElementById('credentialInput').value; if(v.length!=32)return alert("éœ€32ä½"); document.getElementById('qr-modal').style.display='flex'; document.getElementById('qrcode-gen').innerHTML=''; new QRCode(document.getElementById('qrcode-gen'),{text:location.href.split('#')[0]+'#c='+v}); },
            scanQR: () => { document.getElementById('scan-modal').style.display='flex'; const s=new Html5Qrcode("reader"); s.start({facingMode:"environment"},{fps:10},t=>{ if(t.includes('c='))t=t.split('c=')[1]; if(t.length===32){ document.getElementById('credentialInput').value=t; App.stopScan(); setTimeout(()=>App.init(),500); } }); App.stopScan=()=>s.stop().then(()=>document.getElementById('scan-modal').style.display='none').catch(()=>{}); }
        };

        const UI = {
            setStatus: s => document.getElementById('status').innerText = s,
            setProgress: s => document.getElementById('progress-text').innerText = s,
            // æ¸²æŸ“100ä¸ªæ ¼å­
            renderGrid: () => {
                const box = document.getElementById('statusGrid');
                box.innerHTML = '';
                for(let i=0; i<CONFIG.TOTAL_PARTS; i++) {
                    const d = document.createElement('div');
                    d.className = 'grid-item';
                    d.id = `b-${i}`;
                    d.title = `Block ${i+1}`;
                    box.appendChild(d);
                }
            },
            resetGrid: () => { for(let i=0;i<CONFIG.TOTAL_PARTS;i++) document.getElementById(`b-${i}`).className = 'grid-item'; },
            setGrid: (idx, status) => { document.getElementById(`b-${idx}`).className = `grid-item ${status}`; },
            addHistory: (name, size, url) => {
                const div = document.getElementById('history');
                const sizeStr = (size/1024/1024).toFixed(2) + ' MB';
                div.innerHTML = `<div class="log-item"><span>${name} <small style="color:#888">(${sizeStr})</small></span><a href="${url}" download="${name}" style="color:#007aff;font-weight:bold;text-decoration:none">â¬‡ ä¿å­˜</a></div>` + div.innerHTML;
            }
        };

        document.getElementById('fileInput').addEventListener('change', e => { if(e.target.files[0]) App.sendFile(e.target.files[0]); });
        window.onload = () => { if(location.hash.includes('c=')) { document.getElementById('credentialInput').value=location.hash.split('c=')[1]; setTimeout(()=>App.init(),600); } };
    </script>
</body>
</html>
