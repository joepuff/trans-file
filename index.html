<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2Pæ–‡ä»¶ä¸­è½¬ç«™ (V14 Camera)</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    
    <style>
        :root { --primary: #007bff; --bg: #f8f9fa; }
        body { font-family: -apple-system, sans-serif; max-width: 600px; margin: 0 auto; padding: 15px; background: var(--bg); color: #333; }
        
        .card { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); margin-bottom: 15px; }
        
        .input-group { display: flex; gap: 8px; margin-bottom: 15px; }
        input[type="text"] { flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-family: monospace; min-width: 0; }
        
        button { padding: 0 12px; height: 42px; border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer; transition: 0.2s; white-space: nowrap; }
        button:active { transform: scale(0.96); }
        
        /* æŒ‰é’®è‰²ç³» */
        .btn-rand { background: #17a2b8; font-size: 1.2em; }
        .btn-show-qr { background: #6c757d; font-size: 1.2em; }
        .btn-scan { background: #6610f2; font-size: 1.2em; } /* ç´«è‰²æ‰«ç æŒ‰é’® */
        .btn-conn { background: var(--primary); }

        #status { font-size: 0.9em; color: #666; margin-bottom: 10px; padding: 8px; background: #f1f3f5; border-radius: 6px; text-align: center;}

        #panel { display: none; }
        .file-select { border: 2px dashed #007bff; padding: 30px; text-align: center; border-radius: 12px; background: #f0f7ff; cursor: pointer; }
        
        #progress-container { display: none; margin-top: 15px; }
        .progress-bar { height: 12px; background: #e9ecef; border-radius: 6px; overflow: hidden; }
        .progress-fill { height: 100%; background: #28a745; width: 0%; transition: width 0.1s linear; }
        .progress-text { font-size: 0.8em; text-align: center; margin-top: 5px; color: #666; font-variant-numeric: tabular-nums; }

        .history-item { padding: 12px 0; border-bottom: 1px solid #eee; font-size: 0.9em; display: flex; justify-content: space-between; align-items: center; }
        .btn-save { display: inline-block; padding: 5px 10px; background: #28a745; color: white; text-decoration: none; border-radius: 4px; font-size: 0.8em; }

        /* ç”ŸæˆäºŒç»´ç çš„å¼¹çª— */
        #gen-modal { display: none; position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); justify-content:center; align-items:center; z-index:999; flex-direction: column;}
        #qrcode-gen { background: white; padding: 20px; border-radius: 16px; }

        /* æ‰«ææ‘„åƒå¤´çš„å¼¹çª— */
        #scan-modal { display: none; position: fixed; top:0; left:0; width:100%; height:100%; background:black; z-index:1000; flex-direction: column; justify-content: center;}
        #reader { width: 100%; max-width: 500px; margin: 0 auto; background: black; }
        .scan-close { position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); padding: 10px 30px; background: rgba(255,255,255,0.2); border: 1px solid white; border-radius: 20px; color: white; }
    </style>
</head>
<body>
    <div class="card">
        <h3 style="margin-top:0">ğŸ“‚ V14 æ‰«ä¸€æ‰«æ——èˆ°ç‰ˆ</h3>
        <div style="font-size:0.8em; color:#666; margin-bottom:15px;">å†…ç½®æ‘„åƒå¤´æ‰«æ â€¢ 500MB+æµå¼ä¼ è¾“</div>
        
        <div class="input-group">
            <input type="text" id="credentialInput" placeholder="32ä½å‡­è¯" maxlength="32">
            <button class="btn-rand" onclick="generateCredential()" title="éšæœºç”Ÿæˆ">ğŸ²</button>
            <button class="btn-show-qr" onclick="showGenQR()" title="å±•ç¤ºäºŒç»´ç ">ğŸ“±</button>
            <button class="btn-scan" onclick="startCameraScan()" title="æ‰“å¼€æ‘„åƒå¤´æ‰«ä¸€æ‰«">ğŸ“·</button>
            <button class="btn-conn" onclick="initApp()">ğŸš€</button>
        </div>
        
        <div id="status">å‡†å¤‡å°±ç»ª</div>

        <div id="panel">
            <div class="file-select" onclick="document.getElementById('fileInput').click()">
                <div style="font-size:2.5em; margin-bottom:5px">ğŸ“¤</div>
                <div>ç‚¹å‡»é€‰æ‹©å¤§æ–‡ä»¶</div>
                <div style="font-size:0.8em; color:#666; margin-top:5px">(å±å¹•è¯·ä¿æŒå¸¸äº®)</div>
                <input type="file" id="fileInput" style="display:none">
            </div>

            <div id="progress-container">
                <div class="progress-bar"><div class="progress-fill" id="p-fill"></div></div>
                <div class="progress-text" id="p-text">0%</div>
            </div>
        </div>
    </div>

    <div class="card">
        <h4 style="margin:0 0 10px 0">ä¼ è¾“è®°å½•</h4>
        <div id="history">
            <div style="text-align:center; color:#999; font-size:0.8em; padding:10px">æš‚æ— è®°å½•</div>
        </div>
    </div>

    <div id="gen-modal" onclick="this.style.display='none'">
        <div id="qrcode-gen"></div>
        <div style="color:white; margin-top:20px; font-size:0.9em">è®©å¯¹æ–¹æ‰«ææ­¤ç è¿æ¥</div>
    </div>

    <div id="scan-modal">
        <div id="reader"></div>
        <button class="scan-close" onclick="stopCameraScan()">å…³é—­æ‘„åƒå¤´</button>
    </div>

    <script>
        // --- V14 æ–°å¢ï¼šæ‘„åƒå¤´æ‰«æé€»è¾‘ ---
        let html5QrCode;

        function startCameraScan() {
            document.getElementById('scan-modal').style.display = 'flex';
            
            // åˆå§‹åŒ–æ‰«æå™¨
            html5QrCode = new Html5Qrcode("reader");
            
            const config = { fps: 10, qrbox: { width: 250, height: 250 } };
            
            // å¯åŠ¨æ‘„åƒå¤´ (ä¼˜å…ˆåç½®)
            html5QrCode.start({ facingMode: "environment" }, config, onScanSuccess, onScanFailure)
            .catch(err => {
                alert("æ— æ³•å¯åŠ¨æ‘„åƒå¤´ï¼Œè¯·ç¡®ä¿ä½¿ç”¨HTTPSè®¿é—®å¹¶å…è®¸æƒé™ã€‚\né”™è¯¯: " + err);
                stopCameraScan();
            });
        }

        function onScanSuccess(decodedText, decodedResult) {
            // åœæ­¢æ‰«æ
            stopCameraScan();
            
            // è§£æå†…å®¹
            // æ ¼å¼å¯èƒ½æ˜¯ "https://...?#c=abcdef..." æˆ–è€…ç›´æ¥æ˜¯ "abcdef..."
            let code = decodedText;
            if (decodedText.includes('c=')) {
                code = decodedText.split('c=')[1];
            }

            if (code && code.length === 32) {
                document.getElementById('credentialInput').value = code;
                // è‡ªåŠ¨è¿æ¥
                setTimeout(() => initApp(), 500);
            } else {
                alert("æ‰«æåˆ°çš„å†…å®¹ä¸æ˜¯æœ‰æ•ˆçš„32ä½å‡­è¯");
            }
        }

        function onScanFailure(error) {
            // æ‰«æä¸­æœªå‘ç°äºŒç»´ç ï¼Œå¿½ç•¥é”™è¯¯
        }

        function stopCameraScan() {
            if (html5QrCode) {
                html5QrCode.stop().then(() => {
                    html5QrCode.clear();
                    document.getElementById('scan-modal').style.display = 'none';
                }).catch(err => console.error("åœæ­¢å¤±è´¥", err));
            } else {
                document.getElementById('scan-modal').style.display = 'none';
            }
        }

        // --- ä»¥ä¸‹ä¸º V13 æ ¸å¿ƒé€»è¾‘ (ä¿æŒä¸å˜) ---
        const CHUNK_SIZE = 64 * 1024; 
        const CONFIG = {
            pbkdf2: { name: "PBKDF2", hash: "SHA-256", iterations: 100000 },
            aes: { name: "AES-GCM", length: 256 }
        };

        const CryptoCore = {
            key: null,
            async initKey(password) {
                const enc = new TextEncoder();
                const keyMat = await crypto.subtle.importKey("raw", enc.encode(password), {name:"PBKDF2"}, false, ["deriveKey"]);
                const salt = enc.encode("V14_SALT_FIXED"); 
                this.key = await crypto.subtle.deriveKey({...CONFIG.pbkdf2, salt}, keyMat, CONFIG.aes, false, ["encrypt", "decrypt"]);
            },
            async encryptChunk(chunk) {
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const cipher = await crypto.subtle.encrypt({name:"AES-GCM", iv}, this.key, chunk);
                const packed = new Uint8Array(12 + cipher.byteLength);
                packed.set(iv, 0); packed.set(new Uint8Array(cipher), 12);
                return packed;
            },
            async decryptChunk(packed) {
                const iv = packed.slice(0, 12);
                const cipher = packed.slice(12);
                return await crypto.subtle.decrypt({name:"AES-GCM", iv}, this.key, cipher);
            }
        };

        let peer, conn;
        let incomingFile = { chunks: [], meta: null, receivedSize: 0 };
        let isTransferring = false;
        let isReceiving = false;

        function generateCredential() {
            const arr = new Uint8Array(16);
            crypto.getRandomValues(arr);
            const hex = Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
            document.getElementById('credentialInput').value = hex;
        }

        async function initApp() {
            const code = document.getElementById('credentialInput').value.trim();
            if(code.length !== 32) return alert("å‡­è¯å¿…é¡»æ˜¯32ä½å­—ç¬¦");
            
            setStatus("ğŸ” ç”Ÿæˆå¯†é’¥...");
            await CryptoCore.initKey(code);

            const roomId = await hashId(code);
            if(peer) peer.destroy();
            
            setStatus("ğŸŒ è¿æ¥èŠ‚ç‚¹(SSL)...");

            peer = new Peer(roomId, {
                host: '0.peerjs.com',
                port: 443,
                secure: true,
                path: '/',
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                }
            });

            peer.on('open', () => {
                setStatus("âœ… å°±ç»ªï¼ç­‰å¾…æ¥å…¥...");
                peer.on('connection', setupConn);
            });
            peer.on('error', e => {
                if(e.type === 'unavailable-id') {
                    setStatus("ğŸ”— è¿æ¥æˆ¿ä¸»...");
                    const guest = new Peer({
                        host: '0.peerjs.com',
                        port: 443,
                        secure: true,
                        path: '/',
                        config: { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }
                    });
                    guest.on('open', () => setupConn(guest.connect(roomId)));
                } else setStatus("âŒ é”™è¯¯: " + e.type);
            });
        }

        function setupConn(c) {
            conn = c;
            conn.on('open', () => {
                setStatus("ğŸ¤ é€šé“å»ºç«‹");
                document.getElementById('panel').style.display = 'block';
            });
            conn.on('data', handleData);
            conn.on('close', () => setStatus("ğŸ”Œ æ–­å¼€"));
        }

        document.getElementById('fileInput').addEventListener('change', async e => {
            const file = e.target.files[0];
            if(!file || !conn) return;
            if(isTransferring) return alert("æœ‰ä¼ è¾“ä»»åŠ¡ä¸­");

            isTransferring = true;
            showProgress(0);
            
            conn.send({ type: 'meta', name: file.name, size: file.size, mime: file.type });
            
            let offset = 0;
            const reader = new FileReader();

            const readNext = () => {
                const slice = file.slice(offset, offset + CHUNK_SIZE);
                reader.readAsArrayBuffer(slice);
            };

            reader.onload = async (evt) => {
                if(!conn || !conn.open) return;
                const encrypted = await CryptoCore.encryptChunk(evt.target.result);
                conn.send(encrypted); 
                offset += CHUNK_SIZE;
                const percent = Math.min(100, Math.round((offset / file.size) * 100));
                updateProgress(percent, `â¬† å‘é€: ${formatSize(offset)} / ${formatSize(file.size)}`);
                if (offset < file.size) {
                    setTimeout(readNext, 0); 
                } else {
                    conn.send({ type: 'end' });
                    isTransferring = false;
                    setStatus("âœ… å‘é€å®Œæˆ");
                    addHistory(file.name, "â¬† å‘é€", formatSize(file.size));
                    setTimeout(() => document.getElementById('progress-container').style.display='none', 3000);
                }
            };
            readNext();
        });

        async function handleData(data) {
            if (data.type) {
                if (data.type === 'meta') {
                    incomingFile = { chunks: [], meta: data, receivedSize: 0 };
                    isReceiving = true;
                    showProgress(0);
                    setStatus(`â¬‡ æ¥æ”¶: ${data.name}`);
                } else if (data.type === 'end') {
                    finishReceive();
                }
                return;
            }
            if (isReceiving && data instanceof ArrayBuffer) {
                try {
                    const decrypted = await CryptoCore.decryptChunk(data);
                    incomingFile.chunks.push(decrypted);
                    incomingFile.receivedSize += decrypted.byteLength;
                    const percent = Math.min(100, Math.round((incomingFile.receivedSize / incomingFile.meta.size) * 100));
                    updateProgress(percent, `â¬‡ æ¥æ”¶: ${percent}%`);
                } catch(e) {
                    setStatus("âŒ è§£å¯†å¤±è´¥");
                    isReceiving = false;
                }
            }
        }

        function finishReceive() {
            const blob = new Blob(incomingFile.chunks, { type: incomingFile.meta.mime });
            const url = URL.createObjectURL(blob);
            addHistory(incomingFile.meta.name, "â¬‡ æ”¶åˆ°", formatSize(incomingFile.meta.size), url);
            isReceiving = false;
            incomingFile = { chunks: [], meta: null, receivedSize: 0 };
            setStatus("âœ… æ¥æ”¶å®Œæˆ");
            setTimeout(() => document.getElementById('progress-container').style.display='none', 3000);
        }

        function showProgress(p) { document.getElementById('progress-container').style.display = 'block'; updateProgress(p, 'å‡†å¤‡...'); }
        function updateProgress(p, text) {
            document.getElementById('p-fill').style.width = p + '%';
            document.getElementById('p-text').textContent = text;
        }
        function addHistory(name, type, size, url) {
            const div = document.getElementById('history');
            if(div.innerText.includes('æš‚æ— è®°å½•')) div.innerHTML = '';
            const html = `
                <div class="history-item">
                    <div style="overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:65%;">
                        <span style="font-weight:bold; color:${type.includes('â¬†')?'#007bff':'#28a745'}">${type}</span> 
                        ${name}
                    </div>
                    ${url ? `<a href="${url}" download="${name}" class="btn-save">ğŸ’¾ ä¿å­˜</a>` : '<span style="color:#ccc">å·²å‘é€</span>'}
                </div>`;
            div.innerHTML = html + div.innerHTML;
        }
        
        async function hashId(s) {
            const b = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(s));
            return Array.from(new Uint8Array(b)).map(x=>x.toString(16).padStart(2,'0')).join('').substr(0,32);
        }
        function formatSize(b) { return b<1024?b+'B':b<1048576?(b/1024).toFixed(1)+'KB':(b/1048576).toFixed(1)+'MB'; }
        function setStatus(s) { document.getElementById('status').textContent = s; }
        
        // è‡ªåŠ¨è§£æ URL Hash (ç»™å¾®ä¿¡æ‰«ä¸€æ‰«ç›´æ¥æ‰“å¼€ç”¨)
        window.onload = () => {
            if(location.hash.includes('c=')) {
                document.getElementById('credentialInput').value = location.hash.split('c=')[1];
                setTimeout(initApp, 500); 
                history.replaceState(null, null, ' '); 
            }
        };
        
        // ç”ŸæˆäºŒç»´ç é€»è¾‘
        function showGenQR() {
            const c = document.getElementById('credentialInput').value;
            if(c.length!=32) return alert("è¯·å…ˆç”Ÿæˆæˆ–è¾“å…¥32ä½å‡­è¯");
            document.getElementById('gen-modal').style.display = 'flex';
            document.getElementById('qrcode-gen').innerHTML = '';
            new QRCode(document.getElementById('qrcode-gen'), {
                text: location.href.split('#')[0]+'#c='+c,
                width: 220, height: 220
            });
        }
    </script>
</body>
</html>
