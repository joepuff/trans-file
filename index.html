<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å±€åŸŸç½‘äº’ä¼  V32 [åŒæ­¥ç¡®è®¤ç‰ˆ]</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    <style>
        :root { --primary: #007aff; --success: #34c759; --error: #ff3b30; --bg: #f5f5f7; --card: #fff; }
        body { font-family: -apple-system, sans-serif; max-width: 600px; margin: 0 auto; padding: 16px; background: var(--bg); color: #1c1c1e; }
        .card { background: var(--card); padding: 20px; border-radius: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); margin-bottom: 16px; }
        
        .input-group { display: flex; gap: 6px; margin-bottom: 16px; }
        input[type="text"] { flex: 1; padding: 10px; border: 1px solid #e5e5ea; border-radius: 8px; font-family: monospace; letter-spacing: 2px; text-align: center; font-size: 0.9rem; }
        button { border: none; padding: 0 14px; border-radius: 8px; font-weight: 600; cursor: pointer; background: #e5e5ea; font-size: 0.85rem; }
        .btn-main { background: var(--primary); color: white; }

        .grid-compact { display: grid; grid-template-columns: repeat(25, 1fr); gap: 1px; margin: 15px 0; background: #f0f0f0; padding: 2px; border-radius: 4px; }
        .grid-item { aspect-ratio: 1; background: #d1d1d6; border-radius: 1px; font-size: 0; transition: 0.1s; }
        .grid-item.done { background: var(--success); }
        .grid-item.sending { background: var(--primary); }
        .grid-item.error { background: var(--error); }
        /* å¢åŠ ä¸€ä¸ªç­‰å¾…ç¡®è®¤çš„é»„è‰²çŠ¶æ€ */
        .grid-item.waiting { background: #ffcc00; } 

        .drop-zone { border: 2px dashed #c7c7cc; padding: 20px; text-align: center; border-radius: 12px; margin-top: 15px; transition: 0.3s; opacity: 0.5; pointer-events: none; cursor: not-allowed; background: #fafafa; }
        .drop-zone.active { opacity: 1; pointer-events: all; border-color: var(--primary); background: #fff; cursor: pointer; }
        
        .log-item { padding: 8px 0; border-bottom: 1px solid #eee; font-size: 0.8rem; display: flex; justify-content: space-between; align-items: center; }
        .modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); align-items: center; justify-content: center; z-index: 99; }
        #qrcode-gen { background: white; padding: 20px; border-radius: 16px; }
    </style>
</head>
<body>
    <div class="card">
        <h3>V32 æ­¥æ­¥ä¸ºè¥ <span style="font-size:0.75rem;background:#000;color:#fff;padding:2px 6px;border-radius:4px;">ACK Sync</span></h3>
        <div style="color:#8e8e93; font-size:0.75rem; margin-bottom:12px">å‘ä¸€æ®µç­‰ä¸€æ®µ â€¢ ç»å¯¹é˜²ä¸¢åŒ… â€¢ æ¡æ‰‹æ ¡éªŒ</div>

        <div class="input-group">
            <input type="text" id="credentialInput" placeholder="è¾“å…¥32ä½å¯†é’¥" maxlength="32">
        </div>
        <div class="input-group">
            <button onclick="App.genKey()">ğŸ²</button>
            <button onclick="App.showQR()">ğŸ“±</button>
            <button onclick="App.scanQR()">ğŸ“·</button>
            <button class="btn-main" style="flex:2" onclick="App.init()">ğŸš€ è¿æ¥</button>
        </div>
        <div id="status" style="text-align:center; color:#666; font-size:0.85rem;">ç­‰å¾…è¿æ¥...</div>

        <div id="panel" style="display:none">
            <div class="grid-compact" id="statusGrid"></div>
            <div id="progress-text" style="text-align:center; font-size:0.75rem; color:#8e8e93; margin-bottom:10px;">ç­‰å¾…æ ¡éªŒ...</div>
            <div class="drop-zone" id="dropZone">
                <div style="font-size:1.5rem">ğŸ“„</div>
                <div id="dropText" style="font-size:0.9rem">ç­‰å¾…æ¡æ‰‹...</div>
            </div>
            <input type="file" id="fileInput" style="display:none">
        </div>
    </div>

    <div class="card">
        <h4 style="font-size:0.9rem; margin:0 0 10px 0">ä¼ è¾“è®°å½•</h4>
        <div id="history"></div>
    </div>

    <div id="qr-modal" class="modal" onclick="this.style.display='none'"><div id="qrcode-gen"></div></div>
    <div id="scan-modal" class="modal"><div style="background:white;padding:10px;border-radius:10px"><div id="reader" style="width:300px"></div><button onclick="App.stopScan()" style="width:100%;margin-top:10px;padding:10px">å…³é—­</button></div></div>

    <script>
        const CONFIG = {
            CHUNK_SIZE: 16 * 1024, 
            TOTAL_PARTS: 100, 
            SALT: "V32_ACK_SALT",
            THROTTLE_MS: 3 // ä¿æŒå¾®å°å»¶æ—¶ï¼ŒåŒé‡ä¿é™©
        };

        const MultiCrypto = {
            subKeys: [], keyHash: null,
            async init(mainKey) {
                if(mainKey.length !== 32) throw new Error("Key len != 32");
                this.subKeys = [];
                const enc = new TextEncoder();
                for(let i=0; i<16; i++) {
                    const subSeed = mainKey.substr(i*2, 2);
                    const keyMat = await crypto.subtle.importKey("raw", enc.encode(subSeed + CONFIG.SALT), {name:"PBKDF2"}, false, ["deriveKey"]);
                    const key = await crypto.subtle.deriveKey({ name: "PBKDF2", salt: enc.encode(i.toString()), iterations: 5000, hash: "SHA-256" }, keyMat, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
                    this.subKeys.push(key);
                }
                const fingerprint = await crypto.subtle.digest('SHA-256', enc.encode(mainKey + "HANDSHAKE_V32"));
                this.keyHash = Array.from(new Uint8Array(fingerprint)).map(b=>b.toString(16).padStart(2,'0')).join('').slice(0, 8);
                const hash = await crypto.subtle.digest('SHA-256', enc.encode(mainKey));
                return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join('').slice(0, 32);
            },
            async encrypt(partIndex, chunkData) {
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const cipher = await crypto.subtle.encrypt({name:"AES-GCM", iv}, this.subKeys[partIndex%16], chunkData);
                const packed = new Uint8Array(12 + cipher.byteLength);
                packed.set(iv, 0); packed.set(new Uint8Array(cipher), 12);
                return packed;
            },
            async decrypt(partIndex, packedData) {
                const iv = packedData.slice(0, 12);
                const cipher = packedData.slice(12);
                return await crypto.subtle.decrypt({name:"AES-GCM", iv}, this.subKeys[partIndex%16], cipher);
            }
        };

        const App = {
            peer: null, conn: null, isVerified: false,
            // ğŸ”¥ æ–°å¢ ackResolver ç”¨äºæš‚åœ/æ¢å¤å‘é€
            ackResolver: null,
            state: { file: null, parts: [], meta: null, partCounts: new Array(CONFIG.TOTAL_PARTS).fill(0), hasError: false },

            async init() {
                const input = document.getElementById('credentialInput').value.trim();
                if(input.length !== 32) return UI.setStatus("âŒ å¯†é’¥é•¿åº¦é”™è¯¯");
                UI.setStatus("ğŸ” è®¡ç®—å¯†é’¥...");
                try {
                    const roomId = await MultiCrypto.init(input);
                    this.startPeer(roomId);
                } catch(e) { UI.setStatus("âŒ å¯†é’¥æ— æ•ˆ"); }
            },

            startPeer(id) {
                if(this.peer) this.peer.destroy();
                this.peer = new Peer(id, { host: '0.peerjs.com', port: 443, secure: true, config: { iceServers: [{ urls: 'stun:stun.miwifi.com' }] } });
                this.peer.on('open', () => { UI.setStatus("âœ… å°±ç»ª (Host)"); this.peer.on('connection', c => this.setupConn(c)); });
                this.peer.on('error', e => { if(e.type==='unavailable-id'){ UI.setStatus("ğŸ”— è¿æ¥ Host..."); const g=new Peer(); g.on('open',()=>this.setupConn(g.connect(id))); } });
            },

            setupConn(c) {
                this.conn = c;
                c.on('open', () => {
                    UI.setStatus("ğŸ¤ å·²è¿æ¥ï¼Œæ ¡éªŒä¸­..."); 
                    document.getElementById('panel').style.display='block'; 
                    UI.renderGrid();
                    c.send({ type: 'handshake', hash: MultiCrypto.keyHash });
                });
                c.on('data', d => this.handleData(d));
                c.on('close', () => { UI.setStatus("ğŸ”Œ æ–­å¼€"); this.isVerified=false; UI.toggleDrop(false); });
            },

            async sendFile(file) {
                if(!this.isVerified) return;
                this.state.file = file;
                UI.resetGrid();
                const partSize = Math.ceil(file.size / CONFIG.TOTAL_PARTS);
                this.conn.send({ type: 'meta', name: file.name, size: file.size, mime: file.type });
                UI.setProgress(`æ­£åœ¨å‘é€: ${file.name}`);

                for(let i=0; i < CONFIG.TOTAL_PARTS; i++) {
                    UI.setGrid(i, 'sending');
                    const start = i * partSize;
                    const end = Math.min(start + partSize, file.size);
                    
                    if(start >= file.size) { 
                        // ç©ºæ®µä¹Ÿè¦ç­‰ ACKï¼Œä¿æŒåŒæ­¥
                        this.conn.send({ type: 'part-end', p: i, count: 0 }); 
                        await this.waitForAck(i);
                        UI.setGrid(i, 'done'); 
                        continue; 
                    }

                    const partBlob = file.slice(start, end);
                    await this.sendPart(i, partBlob);
                    
                    // ğŸ”¥ æ ¸å¿ƒæ”¹å˜ï¼šå‘å®Œä¸€æ®µåï¼Œè®¾ç½®æ ¼å­ä¸ºé»„è‰²(Waiting)ï¼Œå¹¶æš‚åœç­‰å¾…æ¥æ”¶æ–¹ç¡®è®¤
                    UI.setGrid(i, 'waiting');
                    await this.waitForAck(i);
                    UI.setGrid(i, 'done');
                }
                this.conn.send({ type: 'all-done' });
                UI.setProgress("âœ… å‘é€å®Œæˆ");
            },

            // ç­‰å¾… ACK çš„ Promise é”
            async waitForAck(partIndex) {
                return new Promise(resolve => {
                    this.ackResolver = resolve;
                });
            },

            async sendPart(p, blob) {
                const buffer = await blob.arrayBuffer();
                const totalChunks = Math.ceil(buffer.byteLength / CONFIG.CHUNK_SIZE);
                for(let j=0; j<totalChunks; j++) {
                    while (this.conn.dataChannel.bufferedAmount > 0) await new Promise(r => setTimeout(r, 2));
                    const chunkOffset = j * CONFIG.CHUNK_SIZE;
                    const chunkData = buffer.slice(chunkOffset, chunkOffset + CONFIG.CHUNK_SIZE);
                    const encrypted = await MultiCrypto.encrypt(p, chunkData);
                    this.conn.send({ type: 'data', p: p, c: j, d: encrypted });
                    // ä¾ç„¶ä¿ç•™å¾®å°å»¶æ—¶ï¼Œå¹³æ»‘ç½‘ç»œæ³¢åŠ¨
                    if(CONFIG.THROTTLE_MS > 0) await new Promise(r => setTimeout(r, CONFIG.THROTTLE_MS));
                }
                this.conn.send({ type: 'part-end', p: p, count: totalChunks });
            },

            async handleData(data) {
                // 1. æ¡æ‰‹
                if(data.type === 'handshake') {
                    if(data.hash === MultiCrypto.keyHash) {
                        this.isVerified = true;
                        UI.setStatus("âœ… å®‰å…¨é€šé“å·²å»ºç«‹");
                        UI.toggleDrop(true);
                    } else {
                        UI.setStatus("âŒ å¯†é’¥ä¸ä¸€è‡´"); alert("å¯†é’¥ä¸åŒ¹é…"); this.conn.close();
                    }
                    return;
                }
                if(!this.isVerified) return;

                // 2. ACK ä¿¡å·
                if(data.type === 'ack') {
                    // å¦‚æœå‘é€æ–¹æ­£åœ¨ç­‰é”ï¼Œè§£å¼€å®ƒ
                    if(this.ackResolver) {
                        this.ackResolver(); 
                        this.ackResolver = null;
                    }
                    return;
                }

                // 3. æ¥æ”¶é€»è¾‘
                if(data.type === 'meta') {
                    this.state.meta = data;
                    this.state.parts = new Array(CONFIG.TOTAL_PARTS).fill(null).map(() => []);
                    this.state.partCounts = new Array(CONFIG.TOTAL_PARTS).fill(0);
                    this.state.hasError = false;
                    UI.resetGrid();
                    UI.setProgress(`â¬‡ æ­£åœ¨æ¥æ”¶...`);
                    return;
                }
                if(data.type === 'data') {
                    const { p, c, d } = data;
                    if(this.state.hasError) return;
                    UI.setGrid(p, 'sending');
                    try {
                        const decrypted = await MultiCrypto.decrypt(p, d);
                        this.state.parts[p][c] = decrypted;
                        this.state.partCounts[p]++;
                    } catch(e) { UI.setGrid(p, 'error'); this.state.hasError = true; }
                    return;
                }
                if(data.type === 'part-end') {
                    const { p, count } = data;
                    if (this.state.partCounts[p] !== count) { UI.setGrid(p, 'error'); this.state.hasError = true; return; }
                    if(this.state.parts[p].length > 0) this.state.parts[p] = new Blob(this.state.parts[p]);
                    
                    UI.setGrid(p, 'done');
                    // ğŸ”¥ æ ¸å¿ƒæ”¹å˜ï¼šæ¥æ”¶ç«¯æ ¡éªŒæ— è¯¯åï¼Œå‘é€ ACK ä¿¡å·
                    this.conn.send({ type: 'ack', p: p });
                }
                if(data.type === 'all-done') {
                    if(!this.state.hasError) this.assembleFile();
                    else UI.setProgress("âŒ ä¼ è¾“é”™è¯¯");
                }
            },

            assembleFile() {
                try {
                    const meta = this.state.meta;
                    const validParts = this.state.parts.map(p => { if(p instanceof Blob) return p; if(Array.isArray(p)&&p.length===0) return new Blob([]); throw new Error(); });
                    const finalBlob = new Blob(validParts, { type: meta.mime });
                    const url = URL.createObjectURL(finalBlob);
                    UI.addHistory(meta.name, meta.size, url);
                    UI.setProgress("âœ… ä¼ è¾“æˆåŠŸ");
                    this.state.parts = []; 
                } catch(e) { UI.setProgress("âŒ åˆå¹¶å¤±è´¥"); }
            },

            genKey: () => document.getElementById('credentialInput').value = Array.from(crypto.getRandomValues(new Uint8Array(16))).map(b=>b.toString(16).padStart(2,'0')).join(''),
            showQR: () => { const v=document.getElementById('credentialInput').value; if(v.length!=32)return alert("éœ€32ä½"); document.getElementById('qr-modal').style.display='flex'; document.getElementById('qrcode-gen').innerHTML=''; new QRCode(document.getElementById('qrcode-gen'),{text:location.href.split('#')[0]+'#c='+v}); },
            scanQR: () => { document.getElementById('scan-modal').style.display='flex'; const s=new Html5Qrcode("reader"); s.start({facingMode:"environment"},{fps:10},t=>{ if(t.includes('c='))t=t.split('c=')[1]; if(t.length===32){ document.getElementById('credentialInput').value=t; App.stopScan(); setTimeout(()=>App.init(),500); } }); App.stopScan=()=>s.stop().then(()=>document.getElementById('scan-modal').style.display='none').catch(()=>{}); }
        };

        const UI = {
            setStatus: s => document.getElementById('status').innerText = s,
            setProgress: s => document.getElementById('progress-text').innerText = s,
            toggleDrop: (enable) => {
                const el = document.getElementById('dropZone');
                const txt = document.getElementById('dropText');
                if(enable) { el.classList.add('active'); txt.innerText = "ç‚¹å‡»é€‰æ‹©æ–‡ä»¶"; }
                else { el.classList.remove('active'); txt.innerText = "ç­‰å¾…æ¡æ‰‹..."; }
            },
            renderGrid: () => { const box=document.getElementById('statusGrid'); box.innerHTML=''; for(let i=0;i<CONFIG.TOTAL_PARTS;i++){ const d=document.createElement('div'); d.className='grid-item'; d.id=`b-${i}`; box.appendChild(d); } },
            resetGrid: () => { for(let i=0;i<CONFIG.TOTAL_PARTS;i++) document.getElementById(`b-${i}`).className='grid-item'; },
            setGrid: (idx, status) => { document.getElementById(`b-${idx}`).className = `grid-item ${status}`; },
            addHistory: (name, size, url) => {
                const div = document.getElementById('history');
                const sizeStr = (size/1024/1024).toFixed(2) + ' MB';
                div.innerHTML = `<div class="log-item"><span>${name} <small style="color:#888">(${sizeStr})</small></span><a href="${url}" download="${name}" style="color:#007aff;font-weight:bold;text-decoration:none">â¬‡ ä¿å­˜</a></div>` + div.innerHTML;
            }
        };

        document.getElementById('dropZone').onclick = () => { if(document.getElementById('dropZone').classList.contains('active')) document.getElementById('fileInput').click(); };
        document.getElementById('fileInput').onchange = (e) => { if(e.target.files[0]) { App.sendFile(e.target.files[0]); e.target.value = null; } };
        window.onload = () => { if(location.hash.includes('c=')) { document.getElementById('credentialInput').value=location.hash.split('c=')[1]; setTimeout(()=>App.init(),600); } };
    </script>
</body>
</html>
