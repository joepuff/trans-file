<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å±€åŸŸç½‘äº’ä¼  V24 [Hybrid Final]</title>
    
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    
    <style>
        :root { --primary: #007aff; --success: #34c759; --warning: #ff9500; --danger: #ff3b30; --bg: #f5f5f7; --card: #ffffff; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background: var(--bg); color: #1d1d1f; }
        
        .card { background: var(--card); padding: 24px; border-radius: 20px; box-shadow: 0 8px 30px rgba(0,0,0,0.04); margin-bottom: 24px; transition: transform 0.2s; }
        .subtitle { font-size: 0.85rem; color: #86868b; margin-bottom: 20px; }
        
        .input-group { display: flex; gap: 10px; margin-bottom: 20px; }
        input[type="text"] { flex: 1; padding: 12px 16px; border: 1px solid #d2d2d7; border-radius: 12px; font-family: monospace; outline: none; background: #fbfbfd; }
        
        .action-bar { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 20px; }
        button { height: 48px; border: none; border-radius: 12px; font-weight: 600; cursor: pointer; transition: 0.2s; font-size: 0.95rem; }
        .btn-icon { background: #e5e5ea; color: #1d1d1f; }
        .btn-primary { background: var(--primary); color: white; grid-column: span 2; }
        .btn-primary:active { transform: scale(0.98); opacity: 0.9; }

        #status-pill { display: inline-block; padding: 6px 16px; background: #e5e5ea; border-radius: 20px; font-size: 0.85rem; font-weight: 500; margin-bottom: 20px; color: #6e6e73; transition: 0.3s; }
        .status-success { background: #e1fcdb !important; color: #1d6f42 !important; }
        .status-error { background: #fee2e2 !important; color: #991b1b !important; }
        .status-disk { background: #e0f2fe !important; color: #0369a1 !important; border: 1px solid #bae6fd; }

        .drop-zone { border: 2px dashed #d2d2d7; border-radius: 16px; padding: 40px; text-align: center; cursor: pointer; transition: 0.2s; position: relative; }
        .drop-zone:active { background: #f0f7ff; border-color: var(--primary); }
        .drop-zone.dragover { border-color: var(--primary); background: #f0f7ff; }
        
        .progress-container { margin-top: 24px; display: none; }
        .progress-track { height: 6px; background: #e5e5ea; border-radius: 3px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--primary); width: 0%; transition: width 0.2s linear; }
        .progress-meta { display: flex; justify-content: space-between; font-size: 0.8rem; color: #86868b; margin-top: 8px; font-variant-numeric: tabular-nums; }

        .history-item { display: flex; align-items: center; padding: 12px 0; border-bottom: 1px solid #f5f5f7; gap: 12px; }
        .file-info { flex: 1; min-width: 0; }
        .btn-save { padding: 6px 12px; background: #e8f2ff; color: var(--primary); border-radius: 6px; font-size: 0.8rem; text-decoration: none; font-weight: 600; }

        .modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.4); backdrop-filter: blur(8px); z-index: 100; justify-content: center; align-items: center; }
        .modal-content { background: white; padding: 24px; border-radius: 24px; width: 90%; max-width: 320px; text-align: center; }
    </style>
</head>
<body>
    <div class="card">
        <h3>é—ªä¼  V24 <span style="font-size:0.8rem; background:#007aff; color:#fff; padding:2px 6px; border-radius:4px; vertical-align:middle;">Hybrid Fixed</span></h3>
        <div class="subtitle">æµå¼ç¡¬ç›˜å†™å…¥(Chrome/Edge) â€¢ å†…å­˜å…¼å®¹(iOS)</div>
        
        <div class="input-group">
            <input type="text" id="credentialInput" placeholder="è¾“å…¥æˆ–ç”Ÿæˆ 32ä½ å¯†é’¥" maxlength="32">
        </div>
        <div class="action-bar">
            <button class="btn-icon" onclick="App.genKey()">ğŸ²</button>
            <button class="btn-icon" onclick="App.showQR()">ğŸ“±</button>
            <button class="btn-icon" onclick="App.scanQR()">ğŸ“·</button>
            <button class="btn-primary" onclick="App.init()">ğŸš€ è¿æ¥</button>
        </div>
        
        <div style="text-align:center;">
            <div id="status-pill">ç­‰å¾…è¿æ¥...</div>
        </div>

        <div id="transfer-panel" style="display:none; margin-top:20px;">
            <div class="drop-zone" id="dropArea" onclick="document.getElementById('fileInput').click()">
                <div style="font-size:2.5rem; margin-bottom:10px">ğŸ“¤</div>
                <div style="font-weight:600">ç‚¹å‡»å‘é€æ–‡ä»¶</div>
                <div style="font-size:0.8rem; color:#86868b; margin-top:4px;">æ”¯æŒè¶…å¤§æ–‡ä»¶æµå¼ä¼ è¾“</div>
                <input type="file" id="fileInput" style="display:none" onclick="this.value=null">
            </div>
            
            <div class="progress-container" id="prog-box">
                <div class="progress-track"><div class="progress-fill" id="p-fill"></div></div>
                <div class="progress-meta">
                    <span id="p-status">å‡†å¤‡ä¸­...</span>
                    <span id="p-nums">0/0 MB</span>
                </div>
            </div>
        </div>
    </div>

    <div class="card">
        <h4 style="margin:0 0 16px 0; font-size:1rem;">ä¼ è¾“å†å²</h4>
        <div id="history" style="font-size:0.9rem;"></div>
    </div>

    <div id="qr-modal" class="modal" onclick="this.style.display='none'"><div class="modal-content"><div id="qrcode-gen"></div></div></div>
    <div id="scan-modal" class="modal"><div class="modal-content" style="padding:0; overflow:hidden;"><div id="reader"></div><button onclick="App.stopScan()" style="width:100%; border-radius:0; height:50px; background:#fff; border:none;">å…³é—­</button></div></div>

    <script>
        // --- æ ¸å¿ƒé…ç½® ---
        const CONSTANTS = {
            CHUNK_SIZE: 64 * 1024, 
            ACK_TIMEOUT: 15000, 
            SALT_ROOM: "V24_SALT_ROOM", 
            SALT_KEY: "V24_SALT_KEY"
        };

        // --- å®‰å…¨æ¨¡å— ---
        const Security = {
            key: null,
            async init(pwd) {
                const enc = new TextEncoder();
                const keyMat = await crypto.subtle.importKey("raw", enc.encode(pwd), {name:"PBKDF2"}, false, ["deriveKey"]);
                this.key = await crypto.subtle.deriveKey(
                    { name: "PBKDF2", salt: enc.encode(CONSTANTS.SALT_KEY), iterations: 100000, hash: "SHA-256" },
                    keyMat, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]
                );
                const roomHash = await crypto.subtle.digest('SHA-256', enc.encode(pwd + CONSTANTS.SALT_ROOM));
                return Array.from(new Uint8Array(roomHash)).map(b=>b.toString(16).padStart(2,'0')).join('').slice(0, 32);
            },
            async encrypt(data) {
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const cipher = await crypto.subtle.encrypt({name:"AES-GCM", iv}, this.key, data);
                const packet = new Uint8Array(12 + cipher.byteLength);
                packet.set(iv, 0); packet.set(new Uint8Array(cipher), 12);
                return packet;
            },
            async decrypt(packet) {
                const iv = packet.slice(0, 12);
                const cipher = packet.slice(12);
                return await crypto.subtle.decrypt({name:"AES-GCM", iv}, this.key, cipher);
            }
        };

        // --- çŠ¶æ€ç®¡ç† ---
        const State = {
            peer: null, conn: null,
            isBusy: false,
            ackTimer: null,
            retryCount: 0,
            fileHandle: null, writableStream: null, useStreamMode: false,
            incoming: { chunks: [], meta: null, received: 0, total: 0 },
            sendingFile: null,

            reset() {
                this.isBusy = false;
                this.retryCount = 0;
                this.incoming = { chunks: [], meta: null, received: 0, total: 0 };
                this.fileHandle = null;
                this.writableStream = null;
                this.useStreamMode = false;
                if(this.ackTimer) clearTimeout(this.ackTimer);
                setTimeout(() => { if(!this.isBusy) UI.resetProgress(); }, 1000);
            }
        };

        // --- ä¸»é€»è¾‘ ---
        const App = {
            async init() {
                const pwd = document.getElementById('credentialInput').value.trim();
                if(pwd.length !== 32) return UI.toast("âŒ éœ€32ä½å¯†é’¥", "error");
                UI.toast("ğŸ” åˆå§‹åŒ–...", "normal");
                try {
                    const id = await Security.init(pwd);
                    this.startPeer(id);
                } catch(e) { UI.toast("âŒ å¯†é’¥é”™è¯¯", "error"); }
            },

            startPeer(id) {
                if(State.peer) State.peer.destroy();
                State.peer = new Peer(id, {
                    host: '0.peerjs.com', port: 443, secure: true,
                    config: { iceServers: [{ urls: 'stun:stun.miwifi.com' }, { urls: 'stun:stun.l.google.com:19302' }] }
                });
                State.peer.on('open', () => { 
                    UI.toast("âœ… å°±ç»ª (Host)", "success"); 
                    State.peer.on('connection', c => this.bindConn(c));
                });
                State.peer.on('error', e => {
                    if(e.type === 'unavailable-id') {
                        UI.toast("ğŸ”— è¿æ¥ Host...", "normal");
                        const guest = new Peer({ config: State.peer.options.config });
                        guest.on('open', () => this.bindConn(guest.connect(id)));
                    } else UI.toast(`âŒ ${e.type}`, "error");
                });
            },

            bindConn(c) {
                State.conn = c;
                c.on('open', () => { 
                    UI.toast("ğŸ¤ è¿æ¥æˆåŠŸ", "success");
                    document.getElementById('transfer-panel').style.display = 'block';
                });
                c.on('data', d => this.handleData(d));
                c.on('close', () => { UI.toast("ğŸ”Œ æ–­å¼€", "error"); State.reset(); });
            },

            async sendFile(file) {
                // ğŸ”¥ ä¿®å¤ç‚¹ï¼šæ£€æŸ¥è¿æ¥çŠ¶æ€
                if(!State.conn || !State.conn.open) return UI.toast("âŒ æœªè¿æ¥ï¼Œè¯·å…ˆç‚¹å‡»[è¿æ¥]", "error");
                
                if(State.isBusy && !confirm("ä¸­æ–­å½“å‰ä¼ è¾“ï¼Ÿ")) return;
                State.reset();
                State.isBusy = true;
                State.sendingFile = file;

                const total = Math.ceil(file.size / CONSTANTS.CHUNK_SIZE);
                State.conn.send({ type: 'meta', name: file.name, size: file.size, mime: file.type, total: total });
                this.streamChunks(0, total - 1, total);
            },

            streamChunks(start, end, total, specificList = null) {
                const file = State.sendingFile;
                let queue = specificList || Array.from({length: end-start+1}, (_, i) => start + i);
                const reader = new FileReader();
                let idx = 0;

                const next = async () => {
                    if(!State.isBusy) return;
                    if(idx >= queue.length) {
                        if(!specificList) {
                            State.conn.send({ type: 'end' });
                            UI.updateProgress(100, "â³ ç­‰å¾…å¯¹æ–¹ä¿å­˜...");
                            State.ackTimer = setTimeout(() => { if(State.isBusy) { UI.toast("âš ï¸ å“åº”è¶…æ—¶", "warning"); State.reset(); } }, CONSTANTS.ACK_TIMEOUT);
                        } else {
                            for(let k=0; k<3; k++) State.conn.send({ type: 'retry-end' });
                            UI.updateProgress(100, "ğŸ”„ è¡¥å‘å®Œæ¯•");
                        }
                        return;
                    }

                    const seq = queue[idx];
                    const offset = seq * CONSTANTS.CHUNK_SIZE;
                    const slice = file.slice(offset, offset + CONSTANTS.CHUNK_SIZE);

                    reader.onload = async (e) => {
                        if(State.conn && State.conn.open) {
                            const enc = await Security.encrypt(e.target.result);
                            const burst = specificList ? 3 : 1;
                            for(let k=0; k<burst; k++) State.conn.send({ type: 'chunk', seq, payload: enc });
                            
                            idx++;
                            if(!specificList) UI.updateProgress((seq/total)*100, "ğŸ“¤ å‘é€ä¸­...");
                            setTimeout(next, 0);
                        }
                    };
                    reader.readAsArrayBuffer(slice);
                };
                next();
            },

            async handleData(data) {
                if(data.type === 'transfer-complete') {
                    if(State.ackTimer) clearTimeout(State.ackTimer);
                    UI.toast("âœ… å¯¹æ–¹å·²ä¿å­˜", "success");
                    State.reset();
                    return;
                }

                if(data.type === 'meta') {
                    State.reset();
                    State.isBusy = true;
                    State.incoming.meta = data;
                    State.incoming.total = data.total;
                    State.incoming.chunks = new Array(data.total);
                    
                    if ('showSaveFilePicker' in window) {
                        try {
                            State.fileHandle = await window.showSaveFilePicker({ suggestedName: data.name });
                            State.writableStream = await State.fileHandle.createWritable();
                            State.useStreamMode = true;
                            UI.toast("ğŸ’¾ ç¡¬ç›˜ç›´å†™æ¨¡å¼å·²æ¿€æ´»", "disk");
                        } catch(e) {
                            console.log("å›é€€å†…å­˜æ¨¡å¼");
                            State.useStreamMode = false;
                        }
                    }
                    
                    if(!State.useStreamMode) UI.toast("â¬‡ å†…å­˜æ¨¡å¼æ¥æ”¶ä¸­...", "normal");
                    UI.updateProgress(0, `â¬‡ ${data.name}`);
                    return;
                }

                if(data.type === 'chunk' && State.isBusy) {
                    try {
                        if(!State.incoming.chunks[data.seq]) {
                            const decrypted = await Security.decrypt(data.payload);
                            
                            if (State.useStreamMode && State.writableStream) {
                                await State.writableStream.write({
                                    type: 'write',
                                    position: data.seq * CONSTANTS.CHUNK_SIZE,
                                    data: decrypted
                                });
                                State.incoming.chunks[data.seq] = true;
                            } else {
                                State.incoming.chunks[data.seq] = decrypted;
                            }

                            State.incoming.received++;
                            if(State.incoming.received % 10 === 0 || State.incoming.received === State.incoming.total) {
                                UI.updateProgress((State.incoming.received/State.incoming.total)*100, "â¬‡ æ¥æ”¶ä¸­...");
                            }
                        }
                    } catch(e) {}
                    return;
                }

                if((data.type === 'end' || data.type === 'retry-end') && State.isBusy) {
                    this.verifyAndFinish();
                    return;
                }

                if(data.type === 'retry-req') {
                    UI.toast(`âš ï¸ è¡¥å‘ ${data.list.length} ä¸ªå—`, "warning");
                    this.streamChunks(0,0,0, data.list);
                }
            },

            verifyAndFinish() {
                const missing = [];
                for(let i=0; i<State.incoming.total; i++) {
                    if(!State.incoming.chunks[i]) missing.push(i);
                }

                if(missing.length > 0) {
                    State.retryCount++;
                    if(State.retryCount > 5) {
                        UI.toast("âŒ ä¸¢åŒ…è¿‡å¤šï¼Œå¼ºåˆ¶ç»“æŸ", "error");
                        this.finalizeFile();
                        return;
                    }
                    UI.updateProgress(99, `âš ï¸ ç¬¬${State.retryCount}æ¬¡è¡¥åŒ… (${missing.length})`);
                    State.conn.send({ type: 'retry-req', list: missing });
                } else {
                    this.finalizeFile();
                }
            },

            async finalizeFile() {
                const meta = State.incoming.meta;
                let url = null;

                if (State.useStreamMode && State.writableStream) {
                    try {
                        await State.writableStream.close();
                        UI.toast("âœ… æ–‡ä»¶å·²å†™å…¥ç¡¬ç›˜", "success");
                    } catch(e) { UI.toast("æ–‡ä»¶å…³é—­å¤±è´¥", "error"); }
                } else {
                    let mime = meta.mime || 'application/octet-stream';
                    const cleanChunks = State.incoming.chunks.filter(c => c !== undefined);
                    const blob = new Blob(cleanChunks, { type: mime });
                    url = URL.createObjectURL(blob);
                    UI.toast("âœ… æ–‡ä»¶æ¥æ”¶å®Œæˆ", "success");
                }

                UI.addHistory(meta.name, meta.size, url, meta.mime);
                if(State.conn) State.conn.send({ type: 'transfer-complete' });
                State.reset();
            }
        };

        // --- UI ---
        const UI = {
            toast(msg, type="normal") {
                const el = document.getElementById('status-pill');
                el.innerText = msg;
                el.className = type === 'success' ? 'status-success' : type === 'error' ? 'status-error' : type === 'disk' ? 'status-disk' : '';
                if(type!=='normal') setTimeout(()=>el.className='', 4000);
            },
            updateProgress(p, txt) {
                document.getElementById('prog-box').style.display = 'block';
                document.getElementById('p-fill').style.width = p + '%';
                document.getElementById('p-status').innerText = txt;
            },
            resetProgress() {
                document.getElementById('p-fill').style.width = '0%';
                document.getElementById('p-status').innerText = 'å°±ç»ª';
            },
            addHistory(name, size, url, mime) {
                const box = document.getElementById('history');
                const sizeStr = size > 1024*1024 ? (size/1024/1024).toFixed(1)+' MB' : (size/1024).toFixed(1)+' KB';
                const div = document.createElement('div');
                div.className = 'history-item';
                div.innerHTML = `
                    <div style="font-size:1.5rem">ğŸ“„</div>
                    <div class="file-info">
                        <div style="font-weight:500">${name}</div>
                        <div style="color:#86868b;font-size:0.8rem">${sizeStr}</div>
                    </div>
                    ${url ? `<a href="${url}" download="${name}" class="btn-save">ä¿å­˜</a>` : '<span style="color:#007aff;font-size:0.8rem">âœ… å·²å­˜ç¡¬ç›˜</span>'}
                `;
                box.prepend(div);
            }
        };

        // --- ğŸ”¥ ä¿®å¤ç‚¹ï¼šç»‘å®šäº‹ä»¶ç›‘å¬å™¨ ---
        document.getElementById('fileInput').addEventListener('change', e => {
            if(e.target.files[0]) App.sendFile(e.target.files[0]);
        });
        
        // æ‹–æ‹½æ”¯æŒ
        const dropZone = document.getElementById('dropArea');
        dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', e => { e.preventDefault(); dropZone.classList.remove('dragover'); });
        dropZone.addEventListener('drop', e => {
            e.preventDefault(); dropZone.classList.remove('dragover');
            if(e.dataTransfer.files[0]) App.sendFile(e.dataTransfer.files[0]);
        });

        // è¾…åŠ©é€»è¾‘
        App.genKey = () => document.getElementById('credentialInput').value = Array.from(crypto.getRandomValues(new Uint8Array(16))).map(b=>b.toString(16).padStart(2,'0')).join('');
        App.showQR = () => { const v=document.getElementById('credentialInput').value; if(v.length!=32)return UI.toast("éœ€32ä½å¯†é’¥","error"); document.getElementById('qr-modal').style.display='flex'; document.getElementById('qrcode-gen').innerHTML=''; new QRCode(document.getElementById('qrcode-gen'),{text:location.href.split('#')[0]+'#c='+v}); };
        App.scanQR = () => { document.getElementById('scan-modal').style.display='flex'; const s=new Html5Qrcode("reader"); s.start({facingMode:"environment"},{fps:10,qrbox:250},t=>{ if(t.includes('c='))t=t.split('c=')[1]; if(t.length===32){ document.getElementById('credentialInput').value=t; App.stopScan(); setTimeout(()=>App.init(),500); } }); App.stopScan=()=>s.stop().then(()=>document.getElementById('scan-modal').style.display='none').catch(()=>{}); };

        window.onload = () => { if(location.hash.includes('c=')) { document.getElementById('credentialInput').value=location.hash.split('c=')[1]; history.replaceState(null,null,' '); setTimeout(()=>App.init(),600); } };
    </script>
</body>
</html>
