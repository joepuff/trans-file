<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å±€åŸŸç½‘äº’ä¼  V26 [å®Œæ•´æ€§æ ¡éªŒç‰ˆ]</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    <style>
        :root { --primary: #5856d6; --success: #34c759; --error: #ff3b30; --bg: #f2f2f7; --card: #fff; }
        body { font-family: -apple-system, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background: var(--bg); color: #1c1c1e; }
        .card { background: var(--card); padding: 24px; border-radius: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); margin-bottom: 20px; }
        
        .input-group { display: flex; gap: 8px; margin-bottom: 20px; }
        input[type="text"] { flex: 1; padding: 12px; border: 1px solid #e5e5ea; border-radius: 10px; font-family: monospace; letter-spacing: 2px; text-align: center; }
        button { border: none; padding: 0 20px; border-radius: 10px; font-weight: 600; cursor: pointer; background: #e5e5ea; }
        .btn-main { background: var(--primary); color: white; }

        .grid-16 { display: grid; grid-template-columns: repeat(8, 1fr); gap: 6px; margin: 20px 0; }
        .grid-item { aspect-ratio: 1; background: #e5e5ea; border-radius: 6px; font-size: 0.6rem; display:flex; align-items:center; justify-content:center; color:#fff; font-weight:bold; transition: 0.3s; }
        
        .grid-item.done { background: var(--success); box-shadow: 0 0 5px var(--success); }
        .grid-item.sending { background: var(--primary); animation: pulse 1s infinite; }
        .grid-item.error { background: var(--error); animation: shake 0.3s; }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        @keyframes shake { 0% { transform: translate(1px, 1px); } 50% { transform: translate(-1px, -1px); } 100% { transform: translate(1px, 1px); } }

        .drop-zone { border: 2px dashed #c7c7cc; padding: 30px; text-align: center; border-radius: 12px; cursor: pointer; margin-top: 20px; }
        .log-item { padding: 10px 0; border-bottom: 1px solid #eee; font-size: 0.9rem; display: flex; justify-content: space-between; align-items: center; }
        
        .modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); align-items: center; justify-content: center; z-index: 99; }
        #qrcode-gen { background: white; padding: 20px; border-radius: 16px; }
    </style>
</head>
<body>
    <div class="card">
        <h3>V26 å®Œæ•´æ€§æ ¡éªŒ <span style="font-size:0.8rem;background:#000;color:#fff;padding:2px 6px;border-radius:4px;">Integrity</span></h3>
        <div style="color:#8e8e93; font-size:0.8rem; margin-bottom:15px">ä¸¥æ ¼æ ¡éªŒåˆ†ç‰‡æ•°é‡ â€¢ æœç»ç»¿ç¯æ–‡ä»¶æŸå</div>

        <div class="input-group">
            <input type="text" id="credentialInput" placeholder="è¾“å…¥32ä½ä¸»å¯†é’¥" maxlength="32">
        </div>
        <div class="input-group">
            <button onclick="App.genKey()">ğŸ²</button>
            <button onclick="App.showQR()">ğŸ“±</button>
            <button onclick="App.scanQR()">ğŸ“·</button>
            <button class="btn-main" style="flex:2" onclick="App.init()">ğŸš€ è¿æ¥</button>
        </div>
        <div id="status" style="text-align:center; color:#666; font-size:0.9rem;">ç­‰å¾…è¿æ¥...</div>

        <div id="panel" style="display:none">
            <div class="grid-16" id="statusGrid">
                <script>for(let i=0;i<16;i++)document.write(`<div class="grid-item" id="b-${i}">${i+1}</div>`)</script>
            </div>
            <div id="progress-text" style="text-align:center; font-size:0.8rem; color:#8e8e93; margin-bottom:10px;">å°±ç»ª</div>

            <div class="drop-zone" onclick="document.getElementById('fileInput').click()">
                <div style="font-size:2rem">ğŸ“¦</div>
                <div>ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</div>
                <input type="file" id="fileInput" style="display:none">
            </div>
        </div>
    </div>

    <div class="card">
        <h4>ä¼ è¾“è®°å½•</h4>
        <div id="history"></div>
    </div>

    <div id="qr-modal" class="modal" onclick="this.style.display='none'"><div id="qrcode-gen"></div></div>
    <div id="scan-modal" class="modal"><div style="background:white;padding:10px;border-radius:10px"><div id="reader" style="width:300px"></div><button onclick="App.stopScan()" style="width:100%;margin-top:10px;padding:10px">å…³é—­</button></div></div>

    <script>
        const CONFIG = {
            CHUNK_SIZE: 16 * 1024, 
            SALT: "V26_INTEGRITY_SALT"
        };

        const MultiCrypto = {
            subKeys: [],
            async init(mainKey) {
                if(mainKey.length !== 32) throw new Error("Key len != 32");
                this.subKeys = [];
                const enc = new TextEncoder();
                for(let i=0; i<16; i++) {
                    const subSeed = mainKey.substr(i*2, 2);
                    const keyMat = await crypto.subtle.importKey("raw", enc.encode(subSeed + CONFIG.SALT), {name:"PBKDF2"}, false, ["deriveKey"]);
                    const key = await crypto.subtle.deriveKey({ name: "PBKDF2", salt: enc.encode(i.toString()), iterations: 5000, hash: "SHA-256" }, keyMat, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
                    this.subKeys.push(key);
                }
                const hash = await crypto.subtle.digest('SHA-256', enc.encode(mainKey));
                return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join('').slice(0, 32);
            },
            async encrypt(partIndex, chunkData) {
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const cipher = await crypto.subtle.encrypt({name:"AES-GCM", iv}, this.subKeys[partIndex], chunkData);
                const packed = new Uint8Array(12 + cipher.byteLength);
                packed.set(iv, 0); packed.set(new Uint8Array(cipher), 12);
                return packed;
            },
            async decrypt(partIndex, packedData) {
                const iv = packedData.slice(0, 12);
                const cipher = packedData.slice(12);
                return await crypto.subtle.decrypt({name:"AES-GCM", iv}, this.subKeys[partIndex], cipher);
            }
        };

        const App = {
            peer: null, conn: null,
            state: { 
                file: null, parts: [], meta: null, 
                // ğŸ”¥ æ–°å¢ï¼šè®¡æ•°å™¨ï¼Œç”¨äºå®Œæ•´æ€§æ ¡éªŒ
                partCounts: new Array(16).fill(0), 
                hasError: false 
            },

            async init() {
                const input = document.getElementById('credentialInput').value.trim();
                if(input.length !== 32) return UI.setStatus("âŒ å¿…é¡»è¾“å…¥32ä½å¯†é’¥");
                UI.setStatus("ğŸ” ç”Ÿæˆå¯†é’¥ä¸­...");
                try {
                    const roomId = await MultiCrypto.init(input);
                    this.startPeer(roomId);
                } catch(e) { UI.setStatus("âŒ å¯†é’¥åˆå§‹åŒ–å¤±è´¥"); }
            },

            startPeer(id) {
                if(this.peer) this.peer.destroy();
                this.peer = new Peer(id, {
                    host: '0.peerjs.com', port: 443, secure: true,
                    config: { iceServers: [{ urls: 'stun:stun.miwifi.com' }] }
                });
                this.peer.on('open', () => { UI.setStatus("âœ… å°±ç»ª (Host)"); this.peer.on('connection', c => this.setupConn(c)); });
                this.peer.on('error', e => { if(e.type==='unavailable-id'){ UI.setStatus("ğŸ”— è¿æ¥ Host..."); const g=new Peer(); g.on('open',()=>this.setupConn(g.connect(id))); } });
            },

            setupConn(c) {
                this.conn = c;
                c.on('open', () => { UI.setStatus("ğŸ¤ å·²è¿æ¥"); document.getElementById('panel').style.display='block'; });
                c.on('data', d => this.handleData(d));
                c.on('close', () => UI.setStatus("ğŸ”Œ è¿æ¥æ–­å¼€"));
            },

            async sendFile(file) {
                this.state.file = file;
                UI.resetGrid();
                const partSize = Math.ceil(file.size / 16);
                this.conn.send({ type: 'meta', name: file.name, size: file.size, mime: file.type });
                
                UI.setProgress(`å‡†å¤‡å‘é€: ${file.name}`);

                for(let i=0; i<16; i++) {
                    UI.setGrid(i, 'sending');
                    const start = i * partSize;
                    const end = Math.min(start + partSize, file.size);
                    
                    if(start >= file.size) {
                        // ç©ºæ®µï¼Œç›´æ¥å‘ç»“æŸä¿¡å·ï¼Œcount=0
                        this.conn.send({ type: 'part-end', p: i, count: 0 });
                        UI.setGrid(i, 'done');
                        continue;
                    }

                    const partBlob = file.slice(start, end);
                    await this.sendPart(i, partBlob);
                    UI.setGrid(i, 'done');
                }
                this.conn.send({ type: 'all-done' });
                UI.setProgress("âœ… å‘é€å®Œæˆ");
            },

            async sendPart(p, blob) {
                const buffer = await blob.arrayBuffer();
                const totalChunks = Math.ceil(buffer.byteLength / CONFIG.CHUNK_SIZE);
                
                for(let j=0; j<totalChunks; j++) {
                    // èƒŒå‹æ§åˆ¶ï¼šé˜²æ­¢ç¼“å†²åŒºæº¢å‡º
                    while (this.conn.dataChannel.bufferedAmount > 64 * 1024) await new Promise(r => setTimeout(r, 5));

                    const chunkOffset = j * CONFIG.CHUNK_SIZE;
                    const chunkData = buffer.slice(chunkOffset, chunkOffset + CONFIG.CHUNK_SIZE);
                    const encrypted = await MultiCrypto.encrypt(p, chunkData);
                    
                    this.conn.send({ type: 'data', p: p, c: j, d: encrypted });
                }
                // ğŸ”¥ å…³é”®ç‚¹ï¼šå‘é€æ—¶å‘ŠçŸ¥è¯¥æ®µä¸€å…±æœ‰å¤šå°‘ä¸ªåŒ… (totalChunks)
                this.conn.send({ type: 'part-end', p: p, count: totalChunks });
            },

            async handleData(data) {
                if(data.type === 'meta') {
                    this.state.meta = data;
                    this.state.parts = new Array(16).fill(null).map(() => []);
                    this.state.partCounts = new Array(16).fill(0); // é‡ç½®è®¡æ•°å™¨
                    this.state.hasError = false;
                    UI.resetGrid();
                    UI.setProgress(`â¬‡ å¼€å§‹æ¥æ”¶: ${data.name}`);
                    return;
                }

                if(data.type === 'data') {
                    const { p, c, d } = data;
                    if(this.state.hasError) return; // å¦‚æœå·²ç»å‡ºé”™äº†ï¼Œå°±ä¸å¤„ç†äº†

                    UI.setGrid(p, 'sending');
                    try {
                        const decrypted = await MultiCrypto.decrypt(p, d);
                        this.state.parts[p][c] = decrypted;
                        this.state.partCounts[p]++; // è®°å½•å®æ”¶æ•°é‡
                    } catch(e) { console.error(e); }
                    return;
                }

                if(data.type === 'part-end') {
                    const { p, count } = data;
                    const received = this.state.partCounts[p];
                    
                    // ğŸ”¥ æ ¸å¿ƒæ ¡éªŒï¼šåº”æ”¶æ•°é‡ vs å®æ”¶æ•°é‡
                    if (received !== count) {
                        UI.setGrid(p, 'error');
                        UI.setProgress(`âŒ é”™è¯¯ï¼šç¬¬${p+1}æ®µä¸¢åŒ… (åº”æ”¶${count}/å®æ”¶${received})`);
                        this.state.hasError = true;
                        // è¿™é‡Œå¯ä»¥åŠ è‡ªåŠ¨é‡è¯•é€»è¾‘ï¼Œä½†ä¸ºäº†æ¼”ç¤ºæ¸…æ™°ï¼Œå…ˆæŠ¥é”™
                        return;
                    }

                    // æ ¡éªŒé€šè¿‡ï¼Œè½¬æ¢Blob
                    if(this.state.parts[p].length > 0) {
                        // å†æ¬¡æ£€æŸ¥æœ‰æ²¡æœ‰ undefined çš„ç©ºæ´
                        for(let k=0; k<count; k++) {
                            if(!this.state.parts[p][k]) {
                                UI.setGrid(p, 'error');
                                UI.setProgress(`âŒ é”™è¯¯ï¼šç¬¬${p+1}æ®µå­˜åœ¨ç©ºæ´`);
                                this.state.hasError = true;
                                return;
                            }
                        }
                        const blob = new Blob(this.state.parts[p]);
                        this.state.parts[p] = blob; 
                    }
                    UI.setGrid(p, 'done');
                }

                if(data.type === 'all-done') {
                    if(!this.state.hasError) this.assembleFile();
                    else UI.setProgress("âŒ ä¼ è¾“å¤±è´¥ï¼Œç”±äºåˆ†ç‰‡ä¸¢å¤±æ— æ³•åˆå¹¶");
                }
            },

            assembleFile() {
                try {
                    const meta = this.state.meta;
                    // æœ€åä¸€é“é˜²çº¿ï¼šç¡®ä¿æ‰€æœ‰éƒ¨åˆ†éƒ½æ˜¯ Blobï¼ˆæˆ–è€…ç©ºæ®µçš„ç©ºæ•°ç»„ï¼‰
                    const validParts = this.state.parts.map(p => {
                        if(p instanceof Blob) return p;
                        if(Array.isArray(p) && p.length===0) return new Blob([]);
                        throw new Error("Segment Missing");
                    });

                    const finalBlob = new Blob(validParts, { type: meta.mime });
                    const url = URL.createObjectURL(finalBlob);
                    
                    const div = document.getElementById('history');
                    div.innerHTML = `
                        <div class="log-item">
                            <span>${meta.name}</span>
                            <a href="${url}" download="${meta.name}" style="color:var(--primary);font-weight:bold">ä¿å­˜</a>
                        </div>` + div.innerHTML;
                    
                    UI.setProgress("âœ… æ ¡éªŒé€šè¿‡ï¼Œæ–‡ä»¶å®Œæ•´");
                    this.state.parts = []; // é‡Šæ”¾å†…å­˜
                } catch(e) {
                    UI.setProgress("âŒ åˆå¹¶å¤±è´¥ï¼šéƒ¨åˆ†åˆ†ç‰‡æœªå®Œæˆ");
                }
            },

            // è¾…åŠ©åŠŸèƒ½
            genKey: () => document.getElementById('credentialInput').value = Array.from(crypto.getRandomValues(new Uint8Array(16))).map(b=>b.toString(16).padStart(2,'0')).join(''),
            showQR: () => { const v=document.getElementById('credentialInput').value; if(v.length!=32)return alert("éœ€32ä½"); document.getElementById('qr-modal').style.display='flex'; document.getElementById('qrcode-gen').innerHTML=''; new QRCode(document.getElementById('qrcode-gen'),{text:location.href.split('#')[0]+'#c='+v}); },
            scanQR: () => { document.getElementById('scan-modal').style.display='flex'; const s=new Html5Qrcode("reader"); s.start({facingMode:"environment"},{fps:10},t=>{ if(t.includes('c='))t=t.split('c=')[1]; if(t.length===32){ document.getElementById('credentialInput').value=t; App.stopScan(); setTimeout(()=>App.init(),500); } }); App.stopScan=()=>s.stop().then(()=>document.getElementById('scan-modal').style.display='none').catch(()=>{}); }
        };

        const UI = {
            setStatus: s => document.getElementById('status').innerText = s,
            setProgress: s => document.getElementById('progress-text').innerText = s,
            resetGrid: () => { for(let i=0;i<16;i++) document.getElementById(`b-${i}`).className = 'grid-item'; },
            setGrid: (idx, status) => { document.getElementById(`b-${idx}`).className = `grid-item ${status}`; }
        };

        document.getElementById('fileInput').addEventListener('change', e => { if(e.target.files[0]) App.sendFile(e.target.files[0]); });
        window.onload = () => { if(location.hash.includes('c=')) { document.getElementById('credentialInput').value=location.hash.split('c=')[1]; setTimeout(()=>App.init(),600); } };
    </script>
</body>
</html>
