<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å±€åŸŸç½‘äº’ä¼  V25 [16æ®µåˆ†æ²»ç‰ˆ]</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    <style>
        :root { --primary: #5856d6; --success: #34c759; --bg: #f2f2f7; --card: #fff; }
        body { font-family: -apple-system, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background: var(--bg); color: #1c1c1e; }
        .card { background: var(--card); padding: 24px; border-radius: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); margin-bottom: 20px; }
        
        .input-group { display: flex; gap: 8px; margin-bottom: 20px; }
        input[type="text"] { flex: 1; padding: 12px; border: 1px solid #e5e5ea; border-radius: 10px; font-family: monospace; letter-spacing: 2px; text-align: center; }
        button { border: none; padding: 0 20px; border-radius: 10px; font-weight: 600; cursor: pointer; background: #e5e5ea; }
        .btn-main { background: var(--primary); color: white; }

        /* 16å®«æ ¼çŠ¶æ€æ˜¾ç¤º */
        .grid-16 { display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px; margin: 20px 0; }
        .grid-item { aspect-ratio: 1; background: #e5e5ea; border-radius: 4px; font-size: 0; transition: 0.3s; position: relative; }
        .grid-item.done { background: var(--success); }
        .grid-item.sending { background: var(--primary); animation: pulse 1s infinite; }
        .grid-item.error { background: #ff3b30; }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        .drop-zone { border: 2px dashed #c7c7cc; padding: 30px; text-align: center; border-radius: 12px; cursor: pointer; margin-top: 20px; }
        .log-item { padding: 10px 0; border-bottom: 1px solid #eee; font-size: 0.9rem; display: flex; justify-content: space-between; }
        
        .modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); align-items: center; justify-content: center; z-index: 99; }
        #qrcode-gen { background: white; padding: 20px; border-radius: 16px; }
    </style>
</head>
<body>
    <div class="card">
        <h3>V25 åˆ†æ®µéš”ç¦»ä¼ è¾“ <span style="font-size:0.8rem;background:#000;color:#fff;padding:2px 6px;border-radius:4px;">Stable</span></h3>
        <div style="color:#8e8e93; font-size:0.8rem; margin-bottom:15px">16ç»„å¯†é’¥ç‹¬ç«‹åŠ å¯† â€¢ èƒŒå‹æµæ§é˜²ä¸¢åŒ…</div>

        <div class="input-group">
            <input type="text" id="credentialInput" placeholder="è¾“å…¥32ä½ä¸»å¯†é’¥" maxlength="32">
        </div>
        <div class="input-group">
            <button onclick="App.genKey()">ğŸ² ç”Ÿæˆ</button>
            <button onclick="App.showQR()">ğŸ“± äºŒç»´ç </button>
            <button onclick="App.scanQR()">ğŸ“· æ‰«ç </button>
            <button class="btn-main" style="flex:2" onclick="App.init()">ğŸš€ è¿æ¥</button>
        </div>
        <div id="status" style="text-align:center; color:#666; font-size:0.9rem;">ç­‰å¾…è¿æ¥...</div>

        <div id="panel" style="display:none">
            <div class="grid-16" id="statusGrid">
                <script>for(let i=0;i<16;i++)document.write(`<div class="grid-item" id="b-${i}" title="Part ${i}"></div>`)</script>
            </div>
            <div id="progress-text" style="text-align:center; font-size:0.8rem; color:#8e8e93; margin-bottom:10px;">å°±ç»ª</div>

            <div class="drop-zone" onclick="document.getElementById('fileInput').click()">
                <div style="font-size:2rem">ğŸ“¦</div>
                <div>ç‚¹å‡»é€‰æ‹©æ–‡ä»¶ (å¼ºåˆ¶åˆ‡åˆ†16æ®µ)</div>
                <input type="file" id="fileInput" style="display:none">
            </div>
        </div>
    </div>

    <div class="card">
        <h4>ä¼ è¾“è®°å½•</h4>
        <div id="history"></div>
    </div>

    <div id="qr-modal" class="modal" onclick="this.style.display='none'"><div id="qrcode-gen"></div></div>
    <div id="scan-modal" class="modal"><div style="background:white;padding:10px;border-radius:10px"><div id="reader" style="width:300px"></div><button onclick="App.stopScan()" style="width:100%;margin-top:10px;padding:10px">å…³é—­</button></div></div>

    <script>
        // --- æ ¸å¿ƒé…ç½® ---
        const CONFIG = {
            CHUNK_SIZE: 16 * 1024, // é™ä½åˆ° 16KB ä»¥é…åˆ WebRTC æœ€ä½³ MTU
            TOTAL_PARTS: 16,
            SALT: "V25_ISOLATION"
        };

        // --- å¤šå¯†é’¥å®‰å…¨æ ¸å¿ƒ ---
        const MultiCrypto = {
            subKeys: [], // å­˜å‚¨16ä¸ªAESå¯†é’¥
            
            // åˆå§‹åŒ–ï¼šå°†32å­—ç¬¦æ‹†åˆ†ä¸º16ç»„ï¼Œæ¯ç»„2å­—ç¬¦ä½œä¸ºç§å­æ´¾ç”Ÿç‹¬ç«‹å¯†é’¥
            async init(mainKey) {
                if(mainKey.length !== 32) throw new Error("Key length must be 32");
                this.subKeys = [];
                const enc = new TextEncoder();
                
                for(let i=0; i<16; i++) {
                    const subSeed = mainKey.substr(i*2, 2); // æå–2ä½
                    const keyMat = await crypto.subtle.importKey("raw", enc.encode(subSeed + CONFIG.SALT), {name:"PBKDF2"}, false, ["deriveKey"]);
                    const key = await crypto.subtle.deriveKey(
                        { name: "PBKDF2", salt: enc.encode(i.toString()), iterations: 10000, hash: "SHA-256" },
                        keyMat, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]
                    );
                    this.subKeys.push(key);
                }
                
                // æˆ¿é—´IDç”±ä¸»å¯†é’¥å“ˆå¸Œç”Ÿæˆ
                const hash = await crypto.subtle.digest('SHA-256', enc.encode(mainKey));
                return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join('').slice(0, 32);
            },

            async encrypt(partIndex, chunkData) {
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const key = this.subKeys[partIndex]; // ä½¿ç”¨å¯¹åº”æ®µçš„å¯†é’¥
                const cipher = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, chunkData);
                const packed = new Uint8Array(12 + cipher.byteLength);
                packed.set(iv, 0); packed.set(new Uint8Array(cipher), 12);
                return packed;
            },

            async decrypt(partIndex, packedData) {
                const iv = packedData.slice(0, 12);
                const cipher = packedData.slice(12);
                const key = this.subKeys[partIndex];
                return await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, cipher);
            }
        };

        // --- åº”ç”¨é€»è¾‘ ---
        const App = {
            peer: null, conn: null,
            state: { 
                file: null, 
                parts: [], // æ¥æ”¶ç«¯å­˜å‚¨16ä¸ªéƒ¨åˆ†çš„Buffer
                meta: null,
                activePart: -1 
            },

            async init() {
                const input = document.getElementById('credentialInput').value.trim();
                if(input.length !== 32) return UI.setStatus("âŒ å¿…é¡»è¾“å…¥32ä½å¯†é’¥ (16ç»„x2ä½)");
                
                UI.setStatus("ğŸ” æ­£åœ¨ç”Ÿæˆ16ç»„ç‹¬ç«‹å¯†é’¥...");
                try {
                    const roomId = await MultiCrypto.init(input);
                    this.startPeer(roomId);
                } catch(e) { UI.setStatus("âŒ å¯†é’¥åˆå§‹åŒ–å¤±è´¥"); }
            },

            startPeer(id) {
                if(this.peer) this.peer.destroy();
                this.peer = new Peer(id, {
                    host: '0.peerjs.com', port: 443, secure: true,
                    config: { iceServers: [{ urls: 'stun:stun.miwifi.com' }] }
                });
                this.peer.on('open', () => {
                    UI.setStatus("âœ… èŠ‚ç‚¹å°±ç»ª (Host)");
                    this.peer.on('connection', c => this.setupConn(c));
                });
                this.peer.on('error', err => {
                    if(err.type === 'unavailable-id') {
                        UI.setStatus("ğŸ”— è¿æ¥ Host...");
                        const guest = new Peer();
                        guest.on('open', () => this.setupConn(guest.connect(id)));
                    }
                });
            },

            setupConn(c) {
                this.conn = c;
                c.on('open', () => { 
                    UI.setStatus("ğŸ¤ å·²è¿æ¥"); 
                    document.getElementById('panel').style.display='block';
                });
                c.on('data', d => this.handleData(d));
                c.on('close', () => UI.setStatus("ğŸ”Œ è¿æ¥æ–­å¼€"));
            },

            // --- å‘é€é€»è¾‘ (èƒŒå‹æ§åˆ¶æ ¸å¿ƒ) ---
            async sendFile(file) {
                this.state.file = file;
                UI.resetGrid();
                
                // 1. è®¡ç®—åˆ‡åˆ†
                const partSize = Math.ceil(file.size / 16);
                this.conn.send({ 
                    type: 'meta', 
                    name: file.name, size: file.size, mime: file.type, 
                    partSize: partSize 
                });

                UI.setProgress(`å‡†å¤‡å‘é€: ${file.name}`);
                
                // 2. é€æ®µå‘é€ (Sequential Part Transmission)
                for(let i=0; i<16; i++) {
                    UI.setGrid(i, 'sending');
                    UI.setProgress(`æ­£åœ¨ä¼ è¾“ç¬¬ ${i+1}/16 æ®µ...`);
                    
                    const start = i * partSize;
                    const end = Math.min(start + partSize, file.size);
                    if(start >= file.size) { // æ–‡ä»¶å¤ªå°å¯èƒ½ä¸æ»¡16æ®µ
                        this.conn.send({ type: 'part-end', part: i }); 
                        UI.setGrid(i, 'done');
                        continue; 
                    }

                    const partBlob = file.slice(start, end);
                    await this.sendPart(i, partBlob);
                    
                    UI.setGrid(i, 'done');
                }
                
                this.conn.send({ type: 'all-done' });
                UI.setProgress("âœ… å‘é€å®Œæˆ");
            },

            // å‘é€å•ä¸ªPartï¼Œå†…éƒ¨åˆ‡åˆ†ä¸ºå°Chunk
            async sendPart(partIndex, blob) {
                const buffer = await blob.arrayBuffer();
                const totalChunks = Math.ceil(buffer.byteLength / CONFIG.CHUNK_SIZE);
                
                for(let j=0; j<totalChunks; j++) {
                    // ğŸ”¥ æ ¸å¿ƒä¿®æ­£ï¼šèƒŒå‹æ§åˆ¶ (Backpressure)
                    // å¦‚æœç¼“å†²åŒºç§¯å‹è¶…è¿‡ 64KBï¼Œå°±æš‚åœç­‰å¾…ï¼Œç›´åˆ°æ¸…ç©ºã€‚
                    // è¿™ç»å¯¹èƒ½è§£å†³â€œæ€»æ˜¯ç•™ä¸‹è¡¥å‘ç‰‡æ®µâ€çš„é—®é¢˜ã€‚
                    while (this.conn.dataChannel.bufferedAmount > 64 * 1024) {
                        await new Promise(r => setTimeout(r, 10));
                    }

                    const chunkOffset = j * CONFIG.CHUNK_SIZE;
                    const chunkData = buffer.slice(chunkOffset, chunkOffset + CONFIG.CHUNK_SIZE);
                    
                    // ä½¿ç”¨ç¬¬ partIndex ç»„å¯†é’¥åŠ å¯†
                    const encrypted = await MultiCrypto.encrypt(partIndex, chunkData);
                    
                    this.conn.send({
                        type: 'data',
                        p: partIndex, // Part Index
                        c: j,         // Chunk Index
                        d: encrypted  // Payload
                    });
                }
                // å‘é€è¯¥æ®µç»“æŸä¿¡å·
                this.conn.send({ type: 'part-end', part: partIndex });
            },

            // --- æ¥æ”¶é€»è¾‘ ---
            async handleData(data) {
                if(data.type === 'meta') {
                    this.state.meta = data;
                    // åˆå§‹åŒ–16ä¸ªå­˜å‚¨æ¡¶
                    this.state.parts = new Array(16).fill(null).map(() => []);
                    UI.resetGrid();
                    UI.setProgress(`â¬‡ å¼€å§‹æ¥æ”¶: ${data.name}`);
                    return;
                }

                if(data.type === 'data') {
                    const { p, c, d } = data;
                    UI.setGrid(p, 'sending'); // è§†è§‰åé¦ˆ
                    
                    try {
                        const decrypted = await MultiCrypto.decrypt(p, d);
                        // å­˜å…¥å¯¹åº”æ¡¶çš„å¯¹åº”ä½ç½® (è§£å†³ä¹±åºé—®é¢˜)
                        this.state.parts[p][c] = decrypted;
                    } catch(e) { console.error("è§£å¯†å¤±è´¥", p, c); }
                    return;
                }

                if(data.type === 'part-end') {
                    // è¯¥æ®µæ¥æ”¶å®Œæ¯•ï¼Œåˆå¹¶è¯¥æ®µå†…å­˜ (é‡Šæ”¾å°ç¢ç‰‡)
                    const p = data.part;
                    if(this.state.parts[p].length > 0) {
                        const blob = new Blob(this.state.parts[p]);
                        this.state.parts[p] = blob; // æ›¿æ¢æ•°ç»„ä¸ºBlobï¼ŒèŠ‚çœå†…å­˜
                    }
                    UI.setGrid(p, 'done');
                }

                if(data.type === 'all-done') {
                    this.assembleFile();
                }
            },

            assembleFile() {
                const meta = this.state.meta;
                // åˆå¹¶16ä¸ªBlob
                const finalBlob = new Blob(this.state.parts, { type: meta.mime });
                const url = URL.createObjectURL(finalBlob);
                
                const div = document.getElementById('history');
                div.innerHTML = `
                    <div class="log-item">
                        <span>${meta.name} (${(meta.size/1024/1024).toFixed(1)}MB)</span>
                        <a href="${url}" download="${meta.name}" style="color:var(--primary);font-weight:bold">ä¿å­˜</a>
                    </div>` + div.innerHTML;
                
                UI.setProgress("âœ… æ¥æ”¶æˆåŠŸï¼Œæ–‡ä»¶å·²åˆå¹¶");
                
                // æ¸…ç†å†…å­˜
                this.state.parts = [];
            },

            // è¾…åŠ©
            genKey: () => {
                const arr = new Uint8Array(16); crypto.getRandomValues(arr);
                document.getElementById('credentialInput').value = Array.from(arr).map(b=>b.toString(16).padStart(2,'0')).join('');
            },
            showQR: () => {
                const v = document.getElementById('credentialInput').value;
                if(v.length!=32) return alert("éœ€32ä½");
                document.getElementById('qr-modal').style.display='flex';
                document.getElementById('qrcode-gen').innerHTML='';
                new QRCode(document.getElementById('qrcode-gen'), {text: location.href.split('#')[0]+'#c='+v});
            },
            scanQR: () => {
                document.getElementById('scan-modal').style.display='flex';
                const s = new Html5Qrcode("reader");
                s.start({facingMode:"environment"},{fps:10}, t=>{
                    if(t.includes('c=')) t=t.split('c=')[1];
                    if(t.length===32) { document.getElementById('credentialInput').value=t; App.stopScan(); setTimeout(()=>App.init(),500); }
                });
                App.stopScan = () => s.stop().then(()=>document.getElementById('scan-modal').style.display='none').catch(()=>{});
            }
        };

        const UI = {
            setStatus: s => document.getElementById('status').innerText = s,
            setProgress: s => document.getElementById('progress-text').innerText = s,
            resetGrid: () => {
                for(let i=0;i<16;i++) {
                    const el = document.getElementById(`b-${i}`);
                    el.className = 'grid-item';
                }
            },
            setGrid: (idx, status) => {
                const el = document.getElementById(`b-${idx}`);
                // åªæœ‰çŠ¶æ€å‡çº§æ—¶æ‰æ”¹å˜ (sending -> done)ï¼Œé˜²æ­¢é—ªçƒ
                if(!el.classList.contains('done')) el.className = `grid-item ${status}`;
            }
        };

        document.getElementById('fileInput').addEventListener('change', e => {
            if(e.target.files[0]) App.sendFile(e.target.files[0]);
        });
        
        window.onload = () => { if(location.hash.includes('c=')) { document.getElementById('credentialInput').value=location.hash.split('c=')[1]; setTimeout(()=>App.init(),600); } };
    </script>
</body>
</html>
