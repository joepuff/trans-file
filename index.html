<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å±€åŸŸç½‘äº’ä¼  V28 [æ¡æ‰‹æ ¡éªŒ]</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    <style>
        :root { --primary: #007aff; --success: #34c759; --error: #ff3b30; --bg: #f5f5f7; --card: #fff; }
        body { font-family: -apple-system, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background: var(--bg); color: #1c1c1e; }
        .card { background: var(--card); padding: 24px; border-radius: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); margin-bottom: 20px; }
        
        .input-group { display: flex; gap: 8px; margin-bottom: 20px; }
        input[type="text"] { flex: 1; padding: 12px; border: 1px solid #e5e5ea; border-radius: 10px; font-family: monospace; letter-spacing: 2px; text-align: center; }
        button { border: none; padding: 0 16px; border-radius: 10px; font-weight: 600; cursor: pointer; background: #e5e5ea; font-size: 0.9rem; }
        .btn-main { background: var(--primary); color: white; }

        .grid-100 { display: grid; grid-template-columns: repeat(10, 1fr); gap: 3px; margin: 20px 0; }
        .grid-item { aspect-ratio: 1; background: #e5e5ea; border-radius: 3px; font-size: 0; transition: 0.2s; }
        .grid-item.done { background: var(--success); }
        .grid-item.sending { background: var(--primary); opacity: 0.8; }
        .grid-item.error { background: var(--error); }

        .drop-zone { border: 2px dashed #c7c7cc; padding: 30px; text-align: center; border-radius: 12px; cursor: pointer; margin-top: 20px; opacity: 0.5; pointer-events: none; transition: 0.3s; }
        .drop-zone.ready { opacity: 1; pointer-events: all; border-color: var(--primary); }
        
        .log-item { padding: 10px 0; border-bottom: 1px solid #eee; font-size: 0.85rem; display: flex; justify-content: space-between; align-items: center; }
        .modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); align-items: center; justify-content: center; z-index: 99; }
        #qrcode-gen { background: white; padding: 20px; border-radius: 16px; }
    </style>
</head>
<body>
    <div class="card">
        <h3>V28 æ¡æ‰‹æ ¡éªŒç‰ˆ <span style="font-size:0.8rem;background:#000;color:#fff;padding:2px 6px;border-radius:4px;">Secure</span></h3>
        <div style="color:#8e8e93; font-size:0.8rem; margin-bottom:15px">è¿æ¥æ—¶æ¯”å¯¹å¯†é’¥ â€¢ ä¸¥é˜²è§£å¯†å¤±è´¥</div>

        <div class="input-group">
            <input type="text" id="credentialInput" placeholder="è¾“å…¥32ä½å¯†é’¥" maxlength="32">
        </div>
        <div class="input-group">
            <button onclick="App.genKey()">ğŸ²</button>
            <button onclick="App.showQR()">ğŸ“±</button>
            <button onclick="App.scanQR()">ğŸ“·</button>
            <button class="btn-main" style="flex:2" onclick="App.init()">ğŸš€ è¿æ¥</button>
        </div>
        <div id="status" style="text-align:center; color:#666; font-size:0.9rem;">ç­‰å¾…è¿æ¥...</div>

        <div id="panel" style="display:none">
            <div class="grid-100" id="statusGrid"></div>
            <div id="progress-text" style="text-align:center; font-size:0.8rem; color:#8e8e93; margin-bottom:10px;">è¯·å…ˆç­‰å¾…å¯†é’¥æ ¡éªŒé€šè¿‡...</div>

            <div class="drop-zone" id="dropZone" onclick="document.getElementById('fileInput').click()">
                <div style="font-size:2rem">ğŸ“¦</div>
                <div>ç‚¹å‡»é€‰æ‹©æ–‡ä»¶ (100æ®µ)</div>
                <input type="file" id="fileInput" style="display:none">
            </div>
        </div>
    </div>

    <div class="card">
        <h4>ä¼ è¾“è®°å½•</h4>
        <div id="history"></div>
    </div>

    <div id="qr-modal" class="modal" onclick="this.style.display='none'"><div id="qrcode-gen"></div></div>
    <div id="scan-modal" class="modal"><div style="background:white;padding:10px;border-radius:10px"><div id="reader" style="width:300px"></div><button onclick="App.stopScan()" style="width:100%;margin-top:10px;padding:10px">å…³é—­</button></div></div>

    <script>
        const CONFIG = {
            CHUNK_SIZE: 16 * 1024, 
            TOTAL_PARTS: 100, 
            SALT: "V28_HANDSHAKE_SALT"
        };

        const MultiCrypto = {
            subKeys: [],
            keyHash: null, // ç”¨äºæ¡æ‰‹æ¯”å¯¹

            async init(mainKey) {
                if(mainKey.length !== 32) throw new Error("Key len != 32");
                this.subKeys = [];
                const enc = new TextEncoder();
                
                // 1. ç”Ÿæˆ16ç»„AESå¯†é’¥
                for(let i=0; i<16; i++) {
                    const subSeed = mainKey.substr(i*2, 2);
                    const keyMat = await crypto.subtle.importKey("raw", enc.encode(subSeed + CONFIG.SALT), {name:"PBKDF2"}, false, ["deriveKey"]);
                    const key = await crypto.subtle.deriveKey({ name: "PBKDF2", salt: enc.encode(i.toString()), iterations: 5000, hash: "SHA-256" }, keyMat, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
                    this.subKeys.push(key);
                }
                
                // 2. ç”Ÿæˆä¸»å¯†é’¥æŒ‡çº¹ï¼ˆç”¨äºæ¡æ‰‹æ ¡éªŒï¼‰
                const fingerprint = await crypto.subtle.digest('SHA-256', enc.encode(mainKey + "HANDSHAKE_CHECK"));
                this.keyHash = Array.from(new Uint8Array(fingerprint)).map(b=>b.toString(16).padStart(2,'0')).join('').slice(0, 8); // å–å‰8ä½åšæ ¡éªŒ

                // 3. ç”ŸæˆRoomID
                const hash = await crypto.subtle.digest('SHA-256', enc.encode(mainKey));
                return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join('').slice(0, 32);
            },
            
            async encrypt(partIndex, chunkData) {
                const keyIndex = partIndex % 16; 
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const cipher = await crypto.subtle.encrypt({name:"AES-GCM", iv}, this.subKeys[keyIndex], chunkData);
                const packed = new Uint8Array(12 + cipher.byteLength);
                packed.set(iv, 0); packed.set(new Uint8Array(cipher), 12);
                return packed;
            },
            
            async decrypt(partIndex, packedData) {
                const keyIndex = partIndex % 16;
                const iv = packedData.slice(0, 12);
                const cipher = packedData.slice(12);
                return await crypto.subtle.decrypt({name:"AES-GCM", iv}, this.subKeys[keyIndex], cipher);
            }
        };

        const App = {
            peer: null, conn: null,
            isVerified: false, // æ˜¯å¦é€šè¿‡æ¡æ‰‹
            state: { file: null, parts: [], meta: null, partCounts: new Array(CONFIG.TOTAL_PARTS).fill(0), hasError: false },

            async init() {
                const input = document.getElementById('credentialInput').value.trim();
                if(input.length !== 32) return UI.setStatus("âŒ å¯†é’¥é•¿åº¦é”™è¯¯");
                UI.setStatus("ğŸ” è®¡ç®—å¯†é’¥æŒ‡çº¹...");
                try {
                    const roomId = await MultiCrypto.init(input);
                    this.startPeer(roomId);
                } catch(e) { UI.setStatus("âŒ å¯†é’¥åˆå§‹åŒ–å¤±è´¥"); }
            },

            startPeer(id) {
                if(this.peer) this.peer.destroy();
                this.peer = new Peer(id, {
                    host: '0.peerjs.com', port: 443, secure: true,
                    config: { iceServers: [{ urls: 'stun:stun.miwifi.com' }] }
                });
                this.peer.on('open', () => { UI.setStatus("âœ… å°±ç»ª (Host)"); this.peer.on('connection', c => this.setupConn(c)); });
                this.peer.on('error', e => { if(e.type==='unavailable-id'){ UI.setStatus("ğŸ”— è¿æ¥ Host..."); const g=new Peer(); g.on('open',()=>this.setupConn(g.connect(id))); } });
            },

            setupConn(c) {
                this.conn = c;
                c.on('open', () => {
                    UI.setStatus("ğŸ¤ å·²è¿æ¥ï¼Œæ­£åœ¨æ¡æ‰‹æ ¡éªŒ..."); 
                    document.getElementById('panel').style.display='block'; 
                    UI.renderGrid();
                    // ğŸ”¥ è¿æ¥å»ºç«‹åï¼Œç«‹å³å‘é€æ¡æ‰‹åŒ…
                    c.send({ type: 'handshake', hash: MultiCrypto.keyHash });
                });
                c.on('data', d => this.handleData(d));
                c.on('close', () => { UI.setStatus("ğŸ”Œ æ–­å¼€"); this.isVerified = false; UI.toggleDrop(false); });
            },

            async sendFile(file) {
                if(!this.isVerified) return alert("å¯†é’¥æœªé€šè¿‡æ ¡éªŒï¼Œç¦æ­¢å‘é€ï¼");
                this.state.file = file;
                UI.resetGrid();
                const partSize = Math.ceil(file.size / CONFIG.TOTAL_PARTS);
                this.conn.send({ type: 'meta', name: file.name, size: file.size, mime: file.type });
                
                UI.setProgress(`å‡†å¤‡å‘é€: ${file.name}`);

                for(let i=0; i < CONFIG.TOTAL_PARTS; i++) {
                    UI.setGrid(i, 'sending');
                    const start = i * partSize;
                    const end = Math.min(start + partSize, file.size);
                    
                    if(start >= file.size) {
                        this.conn.send({ type: 'part-end', p: i, count: 0 }); 
                        UI.setGrid(i, 'done');
                        continue;
                    }

                    const partBlob = file.slice(start, end);
                    await this.sendPart(i, partBlob);
                    UI.setGrid(i, 'done');
                }
                this.conn.send({ type: 'all-done' });
                UI.setProgress("âœ… å‘é€å®Œæˆ");
            },

            async sendPart(p, blob) {
                const buffer = await blob.arrayBuffer();
                const totalChunks = Math.ceil(buffer.byteLength / CONFIG.CHUNK_SIZE);
                
                for(let j=0; j<totalChunks; j++) {
                    // ğŸ”¥ é›¶ç¼“å†²æµæ§ï¼šåªè¦ç¼“å†²åŒºæœ‰æ•°æ®å°±ç­‰ï¼Œç¡®ä¿ç»å¯¹ä¸ä¸¢åŒ…
                    while (this.conn.dataChannel.bufferedAmount > 0) {
                        await new Promise(r => setTimeout(r, 2));
                    }

                    const chunkOffset = j * CONFIG.CHUNK_SIZE;
                    const chunkData = buffer.slice(chunkOffset, chunkOffset + CONFIG.CHUNK_SIZE);
                    const encrypted = await MultiCrypto.encrypt(p, chunkData);
                    
                    this.conn.send({ type: 'data', p: p, c: j, d: encrypted });
                }
                this.conn.send({ type: 'part-end', p: p, count: totalChunks });
            },

            async handleData(data) {
                // ğŸ”¥ 1. æ¡æ‰‹æ ¡éªŒé€»è¾‘
                if(data.type === 'handshake') {
                    if(data.hash === MultiCrypto.keyHash) {
                        this.isVerified = true;
                        UI.setStatus("âœ… å¯†é’¥æ ¡éªŒé€šè¿‡ï¼Œé€šé“å®‰å…¨");
                        UI.toggleDrop(true);
                        // å¦‚æœæˆ‘æ˜¯æ¥æ”¶æ–¹ï¼Œä¹Ÿå›å‘ä¸€ä¸ªæ¡æ‰‹ï¼Œç¡®ä¿åŒå‘è®¤è¯
                        if(this.peer.id !== this.conn.peer) { // ç®€å•åˆ¤æ–­é¿å…æ­»å¾ªç¯ï¼Œå®é™…P2Pä¸ç”¨å¤ªä¸¥æ ¼
                             // å®é™…ä¸Šä¸€æ¡æ¶ˆæ¯å·²ç»é€šäº†ï¼Œè¿™é‡Œåªæ˜¯æ›´æ–°UIçŠ¶æ€
                        }
                    } else {
                        UI.setStatus("âŒ ä¸¥é‡é”™è¯¯ï¼šåŒæ–¹å¯†é’¥ä¸ä¸€è‡´ï¼");
                        alert("åŒæ–¹å¯†é’¥ä¸ä¸€è‡´ï¼\nè¯·æ£€æŸ¥32ä½å‡­è¯æ˜¯å¦å®Œå…¨ç›¸åŒã€‚\næ— æ³•è¿›è¡ŒåŠ å¯†é€šä¿¡ã€‚");
                        this.conn.close();
                    }
                    return;
                }

                // 2. æ­£å¸¸æ•°æ®é€»è¾‘ (åªæœ‰éªŒè¯é€šè¿‡æ‰å¤„ç†)
                if(!this.isVerified) return;

                if(data.type === 'meta') {
                    this.state.meta = data;
                    this.state.parts = new Array(CONFIG.TOTAL_PARTS).fill(null).map(() => []);
                    this.state.partCounts = new Array(CONFIG.TOTAL_PARTS).fill(0);
                    this.state.hasError = false;
                    UI.resetGrid();
                    UI.setProgress(`â¬‡ å¼€å§‹æ¥æ”¶ (100æ®µ)`);
                    return;
                }

                if(data.type === 'data') {
                    const { p, c, d } = data;
                    if(this.state.hasError) return;
                    UI.setGrid(p, 'sending');
                    try {
                        const decrypted = await MultiCrypto.decrypt(p, d);
                        this.state.parts[p][c] = decrypted;
                        this.state.partCounts[p]++;
                    } catch(e) { 
                        // ğŸ”¥ æ•è·è§£å¯†é”™è¯¯
                        console.error(e);
                        UI.setGrid(p, 'error');
                        UI.setProgress(`âŒ é”™è¯¯ï¼šç¬¬${p+1}æ®µè§£å¯†å¤±è´¥`);
                        this.state.hasError = true;
                    }
                    return;
                }

                if(data.type === 'part-end') {
                    const { p, count } = data;
                    const received = this.state.partCounts[p];
                    
                    if (received !== count) {
                        UI.setGrid(p, 'error');
                        UI.setProgress(`âŒ ä¸¢åŒ…ï¼šç¬¬${p+1}æ®µ (æ”¶${received}/åº”${count})`);
                        this.state.hasError = true;
                        return;
                    }

                    if(this.state.parts[p].length > 0) {
                         // æ£€æŸ¥ç©ºæ´
                        for(let k=0; k<count; k++) if(!this.state.parts[p][k]) {
                            UI.setGrid(p, 'error'); this.state.hasError = true; return;
                        }
                        this.state.parts[p] = new Blob(this.state.parts[p]); 
                    }
                    UI.setGrid(p, 'done');
                }

                if(data.type === 'all-done') {
                    if(!this.state.hasError) this.assembleFile();
                    else UI.setProgress("âŒ ä¼ è¾“å› é”™è¯¯ç»ˆæ­¢");
                }
            },

            assembleFile() {
                try {
                    const meta = this.state.meta;
                    const validParts = this.state.parts.map(p => {
                        if(p instanceof Blob) return p;
                        if(Array.isArray(p) && p.length===0) return new Blob([]);
                        throw new Error("Missing");
                    });
                    const finalBlob = new Blob(validParts, { type: meta.mime });
                    const url = URL.createObjectURL(finalBlob);
                    UI.addHistory(meta.name, meta.size, url);
                    UI.setProgress("âœ… æ ¡éªŒå®Œæ•´ï¼Œåˆå¹¶æˆåŠŸ");
                    this.state.parts = []; 
                } catch(e) { UI.setProgress("âŒ åˆå¹¶å¤±è´¥"); }
            },

            genKey: () => document.getElementById('credentialInput').value = Array.from(crypto.getRandomValues(new Uint8Array(16))).map(b=>b.toString(16).padStart(2,'0')).join(''),
            showQR: () => { const v=document.getElementById('credentialInput').value; if(v.length!=32)return alert("éœ€32ä½"); document.getElementById('qr-modal').style.display='flex'; document.getElementById('qrcode-gen').innerHTML=''; new QRCode(document.getElementById('qrcode-gen'),{text:location.href.split('#')[0]+'#c='+v}); },
            scanQR: () => { document.getElementById('scan-modal').style.display='flex'; const s=new Html5Qrcode("reader"); s.start({facingMode:"environment"},{fps:10},t=>{ if(t.includes('c='))t=t.split('c=')[1]; if(t.length===32){ document.getElementById('credentialInput').value=t; App.stopScan(); setTimeout(()=>App.init(),500); } }); App.stopScan=()=>s.stop().then(()=>document.getElementById('scan-modal').style.display='none').catch(()=>{}); }
        };

        const UI = {
            setStatus: s => document.getElementById('status').innerText = s,
            setProgress: s => document.getElementById('progress-text').innerText = s,
            toggleDrop: (enable) => {
                const el = document.getElementById('dropZone');
                if(enable) { el.classList.add('ready'); el.innerHTML = `<div style="font-size:2rem">ğŸ“¦</div><div>ç‚¹å‡»é€‰æ‹©æ–‡ä»¶ (å®‰å…¨ä¼ è¾“)</div><input type="file" id="fileInput" style="display:none">`; }
                else { el.classList.remove('ready'); }
            },
            renderGrid: () => {
                const box = document.getElementById('statusGrid'); box.innerHTML = '';
                for(let i=0; i<CONFIG.TOTAL_PARTS; i++) { const d = document.createElement('div'); d.className = 'grid-item'; d.id = `b-${i}`; box.appendChild(d); }
            },
            resetGrid: () => { for(let i=0;i<CONFIG.TOTAL_PARTS;i++) document.getElementById(`b-${i}`).className = 'grid-item'; },
            setGrid: (idx, status) => { document.getElementById(`b-${idx}`).className = `grid-item ${status}`; },
            addHistory: (name, size, url) => {
                const div = document.getElementById('history');
                const sizeStr = (size/1024/1024).toFixed(2) + ' MB';
                div.innerHTML = `<div class="log-item"><span>${name} <small style="color:#888">(${sizeStr})</small></span><a href="${url}" download="${name}" style="color:#007aff;font-weight:bold;text-decoration:none">â¬‡ ä¿å­˜</a></div>` + div.innerHTML;
            }
        };

        document.getElementById('dropZone').addEventListener('click', e => { if(e.currentTarget.classList.contains('ready')) document.getElementById('fileInput').click(); });
        document.getElementById('dropZone').addEventListener('change', e => { if(e.target.files[0]) App.sendFile(e.target.files[0]); }, true); // capture phase
        window.onload = () => { if(location.hash.includes('c=')) { document.getElementById('credentialInput').value=location.hash.split('c=')[1]; setTimeout(()=>App.init(),600); } };
    </script>
</body>
</html>
