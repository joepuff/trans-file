<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>p2pæ–‡ä»¶ä¸­è½¬(V18 VideoFix)</title>
    
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    
    <style>
        :root { --primary: #e91e63; --bg: #fdf2f8; } /* æ¢ä¸ªç²‰è‰²ç³»åŒºåˆ†ç‰ˆæœ¬ */
        body { font-family: -apple-system, sans-serif; max-width: 600px; margin: 0 auto; padding: 15px; background: var(--bg); color: #333; }
        
        .card { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); margin-bottom: 15px; }
        .tag { font-size: 0.75em; background: #fce7f3; color: #be185d; padding: 2px 6px; border-radius: 4px; font-weight: bold; margin-left: 5px; }
        
        .input-group { display: flex; gap: 8px; margin-bottom: 15px; }
        input[type="text"] { flex: 1; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-family: monospace; min-width: 0; }
        button { padding: 0 14px; height: 44px; border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer; transition: 0.2s; }
        .btn-rand { background: #0ea5e9; }
        .btn-qr { background: #64748b; }
        .btn-scan { background: #8b5cf6; }
        .btn-conn { background: var(--primary); width: 80px;}
        
        #status { font-size: 0.9em; color: #666; margin-bottom: 15px; padding: 10px; background: #fff1f2; border-radius: 6px; text-align: center; border: 1px dashed #fecdd3; }
        
        .file-select { border: 2px dashed var(--primary); padding: 30px; text-align: center; border-radius: 12px; background: #fff; cursor: pointer; }
        
        .progress-container { margin-top: 15px; display: none; }
        .progress-bar { height: 8px; background: #eee; border-radius: 4px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--primary); width: 0%; transition: width 0.1s linear; }
        .progress-text { font-size: 0.8em; text-align: center; margin-top: 5px; color: #666; }

        .history-item { padding: 15px 0; border-bottom: 1px solid #eee; font-size: 0.9em; }
        .history-meta { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .btn-save { padding: 6px 12px; background: #10b981; color: white; text-decoration: none; border-radius: 6px; font-size: 0.9em; display: inline-block;}
        
        /* V18 æ–°å¢ï¼šè§†é¢‘æ’­æ”¾å™¨æ ·å¼ */
        .media-preview { width: 100%; margin-top: 10px; border-radius: 8px; background: black; max-height: 400px; }
        
        .modal { display: none; position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); justify-content:center; align-items:center; z-index:999; flex-direction: column;}
        #qrcode-gen { background: white; padding: 20px; border-radius: 16px; }
        #reader { width: 100%; max-width: 500px; border-radius: 8px; overflow: hidden; }
        .close-btn { margin-top: 20px; background: transparent; border: 1px solid white; color: white; }
    </style>
</head>
<body>
    <div class="card">
        <h3 style="margin-top:0; display:flex; align-items:center;">
            ğŸ¬ V18 è§†é¢‘ä¿®å¤ç‰ˆ
            <span class="tag">Player-Inside</span>
        </h3>
        
        <div class="input-group">
            <input type="text" id="credentialInput" placeholder="32ä½å‡­è¯" maxlength="32">
            <button class="btn-rand" onclick="generateCredential()">ğŸ²</button>
            <button class="btn-qr" onclick="showGenQR()">ğŸ“±</button>
            <button class="btn-scan" onclick="startCameraScan()">ğŸ“·</button>
            <button class="btn-conn" onclick="initApp()">ğŸš€</button>
        </div>
        
        <div id="status">ğŸ”’ ç­‰å¾…è¿æ¥...</div>

        <div id="panel" style="display:none;">
            <div class="file-select" onclick="document.getElementById('fileInput').click()">
                <div style="font-size:2.5em; margin-bottom:5px">ğŸ“¤</div>
                <div>ç‚¹å‡»é€‰æ‹©æ–‡ä»¶/è§†é¢‘</div>
                <div style="font-size:0.8em; color:#e91e63; margin-top:5px">æ”¯æŒè§†é¢‘åœ¨çº¿æ’­æ”¾</div>
                <input type="file" id="fileInput" style="display:none">
            </div>
            <div class="progress-container" id="progress-box">
                <div class="progress-bar"><div class="progress-fill" id="p-fill"></div></div>
                <div class="progress-text" id="p-text">0%</div>
            </div>
        </div>
    </div>

    <div class="card">
        <h4 style="margin:0 0 10px 0">ä¼ è¾“è®°å½•</h4>
        <div id="history">
            <div style="text-align:center; color:#999; font-size:0.8em; padding:10px">æš‚æ— è®°å½•</div>
        </div>
    </div>

    <div id="gen-modal" class="modal" onclick="this.style.display='none'"><div id="qrcode-gen"></div></div>
    <div id="scan-modal" class="modal"><div id="reader"></div><button class="close-btn" onclick="stopCameraScan()">å…³é—­æ‘„åƒå¤´</button></div>

    <script>
        const CHUNK_SIZE = 64 * 1024; 
        const CONFIG = {
            pbkdf2: { name: "PBKDF2", hash: "SHA-256", iterations: 500000 },
            aes: { name: "AES-GCM", length: 256 },
            salt_room: "V18_VIDEO_ROOM_SALT", salt_key: "V18_VIDEO_KEY_SALT"
        };

        const SecurityCore = {
            encKey: null,
            async init(password) {
                const enc = new TextEncoder();
                const baseKey = await crypto.subtle.importKey("raw", enc.encode(password), {name:"PBKDF2"}, false, ["deriveKey"]);
                this.encKey = await crypto.subtle.deriveKey({ ...CONFIG.pbkdf2, salt: enc.encode(CONFIG.salt_key) }, baseKey, CONFIG.aes, false, ["encrypt", "decrypt"]);
                const roomData = await crypto.subtle.digest('SHA-256', enc.encode(password + CONFIG.salt_room));
                return Array.from(new Uint8Array(roomData)).map(b=>b.toString(16).padStart(2,'0')).join('').substr(0,32);
            },
            async encrypt(chunk) {
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const cipher = await crypto.subtle.encrypt({name:"AES-GCM", iv}, this.encKey, chunk);
                const packed = new Uint8Array(12 + cipher.byteLength);
                packed.set(iv, 0); packed.set(new Uint8Array(cipher), 12);
                return packed;
            },
            async decrypt(packed) {
                const iv = packed.slice(0, 12);
                const cipher = packed.slice(12);
                return await crypto.subtle.decrypt({name:"AES-GCM", iv}, this.encKey, cipher);
            }
        };

        let peer, conn;
        let incoming = { chunks: [], meta: null, recvSize: 0 };
        let isBusy = false;

        async function initApp() {
            const code = document.getElementById('credentialInput').value.trim();
            if(code.length !== 32) return alert("å‡­è¯éœ€32ä½");
            setStatus("ğŸ” æ­£åœ¨æ¥å…¥å›½å†… STUN...");
            setTimeout(async () => {
                try {
                    const roomId = await SecurityCore.init(code);
                    connectPeer(roomId);
                } catch(e) { setStatus("âŒ åˆå§‹åŒ–å¤±è´¥"); }
            }, 50);
        }

        function connectPeer(roomId) {
            if(peer) peer.destroy();
            peer = new Peer(roomId, {
                host: '0.peerjs.com', port: 443, secure: true, path: '/',
                config: {
                    iceServers: [
                        { urls: 'stun:stun.miwifi.com' },
                        { urls: 'stun:stun.chat.bilibili.com'},
                        { urls: 'stun:stun.qq.com' }
                    ]
                }
            });
            peer.on('open', () => { setStatus("âœ… èŠ‚ç‚¹å°±ç»ª (CN-STUN)"); peer.on('connection', setupConn); });
            peer.on('error', e => {
                if(e.type === 'unavailable-id') {
                    setStatus("ğŸ”— è¿æ¥æˆ¿ä¸»...");
                    const guest = new Peer({
                        host: '0.peerjs.com', port: 443, secure: true, path: '/',
                        config: { iceServers: [{ urls: 'stun:stun.miwifi.com' }] }
                    });
                    guest.on('open', () => setupConn(guest.connect(roomId)));
                } else setStatus("âŒ " + e.type);
            });
        }

        function setupConn(c) {
            conn = c;
            conn.on('open', () => { setStatus("ğŸ¤ è¿æ¥æˆåŠŸ"); document.getElementById('panel').style.display = 'block'; });
            conn.on('data', handleData);
            conn.on('close', () => setStatus("ğŸ”Œ æ–­å¼€"));
        }

        document.getElementById('fileInput').addEventListener('change', async e => {
            const file = e.target.files[0];
            if(!file || !conn) return;
            if(isBusy) return alert("å¿™ç¢Œä¸­");
            isBusy = true;
            document.getElementById('progress-box').style.display = 'block';
            
            // æ˜ç¡®ä¼ é€’æ–‡ä»¶ç±»å‹ï¼Œé˜²æ­¢ä¸¢å¤±
            conn.send({ type: 'meta', name: file.name, size: file.size, mime: file.type || 'application/octet-stream' });
            
            let offset = 0;
            const reader = new FileReader();
            const readNext = () => {
                const slice = file.slice(offset, offset + CHUNK_SIZE);
                reader.readAsArrayBuffer(slice);
            };
            reader.onload = async (evt) => {
                if(!conn || !conn.open) return;
                const encrypted = await SecurityCore.encrypt(evt.target.result);
                conn.send(encrypted); 
                offset += CHUNK_SIZE;
                const percent = Math.min(100, Math.round((offset / file.size) * 100));
                updateBar(percent, `â¬† å‘é€ä¸­`);
                if (offset < file.size) setTimeout(readNext, 0); 
                else {
                    conn.send({ type: 'end' });
                    isBusy = false;
                    addLog(file.name, "â¬† å‘é€", formatSize(file.size), null, file.type);
                    setStatus("âœ… å‘é€å®Œæ¯•");
                    setTimeout(()=>document.getElementById('progress-box').style.display='none', 2000);
                }
            };
            readNext();
        });

        async function handleData(data) {
            if (data.type) {
                if (data.type === 'meta') {
                    incoming = { chunks: [], meta: data, recvSize: 0 };
                    isBusy = true;
                    document.getElementById('progress-box').style.display = 'block';
                    setStatus(`â¬‡ æ¥æ”¶: ${data.name}`);
                } else if (data.type === 'end') {
                    finishReceive();
                }
                return;
            }
            if (isBusy && data instanceof ArrayBuffer) {
                try {
                    const decrypted = await SecurityCore.decrypt(data);
                    incoming.chunks.push(decrypted);
                    incoming.recvSize += decrypted.byteLength;
                    const percent = Math.min(100, Math.round((incoming.recvSize / incoming.meta.size) * 100));
                    updateBar(percent, `â¬‡ æ¥æ”¶ä¸­`);
                } catch(e) { isBusy = false; setStatus("âŒ è§£å¯†å¤±è´¥"); }
            }
        }

        function finishReceive() {
            // ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šç¡®ä¿ Blob ä½¿ç”¨æ­£ç¡®çš„ MIME ç±»å‹
            let mime = incoming.meta.mime;
            // å¦‚æœå‘é€ç«¯æ²¡ä¼ ç±»å‹ï¼Œæ ¹æ®åç¼€åçŒœä¸€ä¸‹ï¼ˆé’ˆå¯¹éƒ¨åˆ†å®‰å“æœºï¼‰
            if(!mime || mime === 'application/octet-stream') {
                if(incoming.meta.name.match(/\.mp4$/i)) mime = 'video/mp4';
                else if(incoming.meta.name.match(/\.mov$/i)) mime = 'video/quicktime';
                else if(incoming.meta.name.match(/\.webm$/i)) mime = 'video/webm';
            }

            const blob = new Blob(incoming.chunks, { type: mime });
            const url = URL.createObjectURL(blob);
            
            addLog(incoming.meta.name, "â¬‡ æ”¶åˆ°", formatSize(incoming.meta.size), url, mime);
            
            isBusy = false;
            incoming = { chunks: [], meta: null };
            setStatus("âœ… æ¥æ”¶å®Œæˆ");
            setTimeout(()=>document.getElementById('progress-box').style.display='none', 2000);
        }

        function generateCredential() {
            const arr = new Uint8Array(16); crypto.getRandomValues(arr);
            document.getElementById('credentialInput').value = Array.from(arr).map(b=>b.toString(16).padStart(2,'0')).join('');
        }
        function updateBar(p, txt) { document.getElementById('p-fill').style.width = p + '%'; document.getElementById('p-text').textContent = `${txt} ${p}%`; }
        
        // ğŸ”¥ V18 æ ¸å¿ƒä¿®å¤ï¼šæ™ºèƒ½æ˜¾ç¤ºæ’­æ”¾å™¨
        function addLog(name, type, size, url, mime) {
            const div = document.getElementById('history');
            if(div.innerText.includes('æš‚æ— ')) div.innerHTML = '';
            
            let mediaHtml = '';
            
            // å¦‚æœæ˜¯è§†é¢‘ï¼Œç›´æ¥æ¸²æŸ“ video æ ‡ç­¾
            if (url && mime && mime.startsWith('video/')) {
                mediaHtml = `<video src="${url}" controls class="media-preview" playsinline></video>`;
            } 
            // å¦‚æœæ˜¯å›¾ç‰‡ï¼Œæ¸²æŸ“ img
            else if (url && mime && mime.startsWith('image/')) {
                mediaHtml = `<img src="${url}" class="media-preview" style="object-fit:contain">`;
            }

            const color = type.includes('å‘é€') ? '#e91e63' : '#10b981';
            
            const html = `
                <div class="history-item">
                    <div class="history-meta">
                        <div style="overflow:hidden;white-space:nowrap;text-overflow:ellipsis;max-width:70%;">
                            <span style="color:${color};font-weight:bold">${type}</span> ${name} 
                            <span style="color:#999">(${size})</span>
                        </div>
                        ${url ? `<a href="${url}" download="${name}" class="btn-save">ğŸ’¾ ä¿å­˜</a>` : '<span style="color:#ccc">å·²å‘é€</span>'}
                    </div>
                    ${mediaHtml}
                </div>`;
            div.innerHTML = html + div.innerHTML;
        }

        function formatSize(b) { return b<1024?b+'B':b<1048576?(b/1024).toFixed(1)+'KB':(b/1048576).toFixed(1)+'MB'; }
        function setStatus(s) { document.getElementById('status').textContent = s; }

        let html5QrCode;
        window.onload = () => { if(location.hash.includes('c=')) { document.getElementById('credentialInput').value = location.hash.split('c=')[1]; setTimeout(initApp, 500); history.replaceState(null, null, ' '); } };
        function showGenQR() {
            const c = document.getElementById('credentialInput').value;
            if(c.length!=32) return alert("éœ€32ä½å‡­è¯");
            document.getElementById('gen-modal').style.display = 'flex';
            document.getElementById('qrcode-gen').innerHTML = '';
            new QRCode(document.getElementById('qrcode-gen'), { text: location.href.split('#')[0]+'#c='+c, width: 220, height: 220 });
        }
        function startCameraScan() {
            document.getElementById('scan-modal').style.display = 'flex';
            html5QrCode = new Html5Qrcode("reader");
            html5QrCode.start({ facingMode: "environment" }, { fps: 10, qrbox: { width: 250, height: 250 } }, 
                (decodedText) => { stopCameraScan(); const code = decodedText.includes('c=') ? decodedText.split('c=')[1] : decodedText; if(code.length===32) { document.getElementById('credentialInput').value = code; setTimeout(initApp, 500); } }
            ).catch(() => { alert("æ— æ³•å¯åŠ¨æ‘„åƒå¤´(éœ€HTTPS)"); stopCameraScan(); });
        }
        function stopCameraScan() { if(html5QrCode) html5QrCode.stop().then(() => { html5QrCode.clear(); document.getElementById('scan-modal').style.display = 'none'; }).catch(()=>{}); else document.getElementById('scan-modal').style.display = 'none'; }
    </script>
</body>
</html>
